{
  "name": "base.second.cloud.services.second.default.copy",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--service:', SELF.name, '--', PATH, AUTH);\n      \n      const path = universe.require('path');\n      const fs = universe.require('fs-extra');\n      const micromatch = universe.require('micromatch');\n      \n      // copies nodes AND files \n      // - optionally files are copied (NOT by default) \n  \t\t\n  \t\tlet VOLUME = universe.env.ATTACHED_VOLUME_ROOT;\n      \n      // INPUT.data = {\n      //   from: 'app.xyz',\n      //   to: 'app.xyz2',\n      //   includeChildren: true,\n      //   includeFiles: [],\n      //   fileExcludePatterns: []\n      // }\n      let {\n        from,\n        to,\n        includeFiles,\n        includeChildren,\n        fileExcludePatterns, // array of strings for micromatch  \n        // overwrite,\n      } = INPUT.data;\n      \n      \n      let opts = {};\n      let value;\n      \n      // default exclude pattern is for /node_modules/ directory only \n      fileExcludePatterns = fileExcludePatterns || ['**/node_modules'];\n      fileExcludePatterns = universe.lodash.isArray(fileExcludePatterns) ? fileExcludePatterns : [fileExcludePatterns];\n      \n      let fileFilterFunc = (src, dest) => {\n        // for(let pattern of fileExcludePatterns || []){\n          if(micromatch.some(src, fileExcludePatterns)){\n            console.log('IGNORING:', src);\n            return false;\n          }\n        // }\n        return true;\n      }\n      \n      // Load node(s)\n      let nodesToCopy = await universe.getNodesForPathPattern(from, {\n        includeChildren: includeChildren\n        // includeFiles: INPUT.data.includeFiles,\n      });\n      \n      // expecting a single node for copying \n      if(nodesToCopy.length != 1){\n        return resolve({\n          error: true,\n          message: 'invalid nodesToCopy length: ' + nodesToCopy.length\n        });\n      }\n      \n      let wrote = [];\n      \n      async function copyNode(node){\n        \n        // from: app.second.blog[...]  \n        // to: base.cloud.app.second.blog \n        // to: hello.second.whatever \n        \n        let newPath = node.name.replace(from, to);\n        console.log('oldPath:', node.name, 'newPath:', newPath);\n        \n        let newNode = {\n          name: newPath,\n          type: node.type,\n          data: node.data\n        }\n        let opts = {};\n        let result;\n        try {\n          console.log('putting');\n          result = await universe.putNodeAtPath(newPath, newNode, null, opts);\n          wrote.push(newPath);\n        }catch(err){\n          // determine why failure \n          console.error('Failed putNodeAtPath:', err);\n          return resolve({\n            type: 'types.second.default.error',\n            data: {\n              message: 'Failed putNodeAtPath',\n              error: err\n            }\n          });\n        }\n        \n        // files \n        if(includeFiles){\n          console.log('file copying');\n          try {\n            let exists = await fs.exists(path.join(VOLUME, node.name)); // old path has files? \n            if(exists){\n              console.log('exists, emptying dir');\n              await fs.emptyDir(path.join(VOLUME, newPath)); // empty new directory\n              console.log('copying', path.join(VOLUME, node.name), path.join(VOLUME, newPath));\n              await fs.copy( path.join(VOLUME, node.name), path.join(VOLUME, newPath), {\n                filter: fileFilterFunc\n              } );\n              wrote.push(newPath + '/');\n            } else {\n              // only clear directory if necessary, otherwise don't even create \n              console.log('no files, checking directory');\n              let existsNew = await fs.exists(path.join(VOLUME, newPath)); // old path has files? \n              if(existsNew){\n                // clear \n                console.log('clearing new directory');\n                await fs.emptyDir(path.join(VOLUME, newPath)); // empty new directory\n              }\n            }\n          }catch(err){\n            console.error('fs error:', err);\n          }\n        }\n        \n        for(let tmpNode of node.nodes){\n          await copyNode(tmpNode);\n        }\n        \n      }\n      \n      for(let node of nodesToCopy){\n        await copyNode(node);\n      }\n        \n      let returnResult = {\n        type: 'types.second.default.response.copy_result',\n        data: {\n          copied: true,\n          wrote\n        }\n      };\n      \n      console.log('returnResult of saving copyNode', returnResult);\n      \n      return resolve(returnResult);\n        \n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-16T02:18:32.609Z",
  "updatedAt": "2019-03-16T03:41:22.860Z",
  "nodes": []
}