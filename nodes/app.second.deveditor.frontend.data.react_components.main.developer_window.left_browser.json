{
  "name": "base.second.cloud.app.second.deveditor.frontend.data.react_components.main.developer_window.left_browser",
  "type": "types.second.default.react_component.js",
  "data": {
    "code": "(()=>{\n  \n    //takes an array of JavaScript File objects\n  function getFiles(fileList) {\n      return Promise.all(Object.keys(fileList).map(fileIdx => getFile(fileList[fileIdx])));\n  }\n\n  //take a single JavaScript File object\n  function getFile(file) {\n      var reader = new WINDOW.FileReader();\n      return new Promise((resolve, reject) => {\n          reader.onerror = () => { reader.abort(); reject(new Error(\"Error parsing file\"));}\n          reader.onload = function () {\n\n              //This will result in an array that will be recognized by C#.NET WebApi as a byte[]\n              let bytes = Array.from(new WINDOW.Uint8Array(this.result));\n\n              //if you want the base64encoded file you would use the below line:\n              let base64StringFile = WINDOW.btoa(bytes.map((item) => String.fromCharCode(item)).join(\"\"));\n\n              //Resolve the promise with your custom file structure\n              resolve({ \n                  bytes: bytes,\n                  base64StringFile: base64StringFile,\n                  name: file.name, \n                  type: file.type\n              });\n          }\n          reader.readAsArrayBuffer(file);\n      });\n  }\n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n    \n  function matchRuleShort(str, rule) {\n    return new RegExp(\"^\" + rule.split(\"*\").join(\".*\") + \"$\").test(str);\n  }\n  \n  function pathMatch(path, pattern){\n    // pattern: xyz.%.%.* something \n    \n    let pathSplit = path.split('.');\n    let patternSplit = pattern.split('.');\n  \n    let doesMatch = false;\n    let stopCheckingPathCuzFailed;\n    pathSplit.forEach((name,idx)=>{\n      if(stopCheckingPathCuzFailed){\n        return;\n      }\n  \n      let isLastName = (idx == (pathSplit.length - 1)) ? true:false;\n      let isLastPattern = (idx == (patternSplit.length - 1)) ? true:false;\n  \n      let patternForSegment = patternSplit[idx];\n  \n      // console.log('name', name);\n      // console.log('pattern', pattern);\n      // console.log('isLast', isLast);\n  \n      if(patternForSegment == '**'){\n        // console.log('Match **');\n        stopCheckingPathCuzFailed = true;\n        doesMatch = true;\n        return;\n      }\n      \n      if(patternForSegment == '' && isLastName && isLastPattern){\n        // same as \".*\"\n        doesMatch = true;\n        return;\n      }\n      \n      if(typeof patternForSegment != 'string'){\n        // failed\n        stopCheckingPathCuzFailed = true;\n        return;\n      }\n  \n      if(matchRuleShort(name, patternForSegment)){\n        if(isLastName){\n          if(isLastPattern){\n            doesMatch = true;\n          } else {\n            // not a match \n            stopCheckingPathCuzFailed = true;\n          }\n        } else {\n          // just continue to checking the next part of this path! \n          // console.log('continue checking');\n        }\n      } else {\n        stopCheckingPathCuzFailed = true;\n      }\n  \n    })\n  \n    return doesMatch;\n    \n  }\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            hiding: {},\n            text: '',\n            pastable: false,\n            pasteText: '',\n            showChildren: true\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteNodes();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        @autobind\n        fetchRemoteNodes_OLD(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                responseType: 'cjson',\n                                dataFilter: {\n                                  nodeId: null\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      // let childNodes = INPUT.data.inputNode.nodes;\n                                      \n                                      // let returnNode = miniverse.lodash.omit(,['data']);\n                                      \n                                      // rebuild children w/o data \n                                      function noData(node){\n                                                                            \n                                        // active: true\n                                        // createdAt: 1524632541511\n                                        // name: \"platform_nodes\"\n                                        // nodeId: \"5ae00bdd6b2f710021b72238\"\n                                        // nodes: (86)\n                                        // parent: Node,\n                                        // placeholder: false\n                                        // type: \"platform_nodes:Qmtlksjflsdjfljf\"\n                                        // updatedAt: null\n                                        // _id: \"5ae00bdd6b2f710021b72239\"\n                                        // _path: \"app_store_cloud.platform_nodes\"\n                                        // _root: Node,\n                                        // _rootChain: (2) []\n                                        \n                                        let newNode = miniverse.lodash.pick(node, [\n                                          '_id',\n                                          'nodeId',\n                                          'type',\n                                          'name',\n                                          '_path',\n                                          'placeholder',\n                                          'createdAt',\n                                          'updatedAt'\n                                        ])\n                                        newNode.data = undefined;\n                                        newNode.nodes = [];\n                                        if(node.nodes){\n                                          node.nodes.forEach(tmpNode2=>{\n                                            newNode.nodes.push(noData(tmpNode2));\n                                          })\n                                        }\n                                        return newNode;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data; // deletes in memory?\n                                      // inputNode.data2 = 'testing2';\n              \n                                      return noData(inputNode);\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              if(typeof nodes == 'string'){\n                console.log('cjson returned for nodes');\n                nodes = universe.cJSON.parse(nodes);\n              } else {\n                console.log('NOT CJSON!');\n              }\n              \n              console.log('Nodes:', nodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes,\n                fetchingRemote: false\n              })\n              \n              // // Update the \"editingNode\" too \n              // // - ideally wouldn't reload the window, but oh well? \n              // let editingNode = this.props.state.editingNode;\n              // if(editingNode){\n                \n              //   function checkChildren(nodes){\n              //     for(let node of nodes){\n              //       if(node._id == editingNode._id){\n              //         editingNode = node;\n              //       }\n              //       if(node.nodes){\n              //         checkChildren(node.nodes);\n              //       }\n              //     }\n              //   }\n              //   checkChildren(nodes);\n              // }\n              \n              // console.log('EditingNode to update:', editingNode);\n              // // this.props.setState({\n              // //   editingNode\n              // // });\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n        // fetchRemoteNodesByPath(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true,\n                fetchingRemoteError: false\n              })\n              \n              \n              \n              universe.$.ajax({\n                url: '/api/get_for_pattern',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  paths: ['*'],\n                  excludeData: true\n                }),\n                success: result=>{\n                  console.log('Got result from /get!'); //, result);\n                  \n                  let nodes = result; // TODO: result.data.nodes when type is setup \n                  \n                  if(typeof nodes == 'string'){\n                    console.log('cjson returned for nodes');\n                    nodes = universe.cJSON.parse(nodes);\n                  } else {\n                    console.log('NOT CJSON!');\n                  }\n                  \n                  // console.log('Nodes:', nodes);\n                  \n                  // let componentNode = await universe.runInVM(result[0],{});\n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  let nodesByPath = {};\n                  function addAllPaths(nArr){\n                    for(let node of nArr){\n                      nodesByPath[node.name] = node;\n                      addAllPaths(node.nodes);\n                    }\n                  }\n                  addAllPaths(nodes);\n                  \n                  this.props.setState({\n                    nodes,\n                    nodesByPath,\n                    selectedNodes: []\n                  })\n                  \n                  // // Update the \"editingNode\" too \n                  // // - ideally wouldn't reload the window, but oh well? \n                  // let editingNode = this.props.state.editingNode;\n                  // if(editingNode){\n                    \n                  //   function checkChildren(nodes){\n                  //     for(let node of nodes){\n                  //       if(node._id == editingNode._id){\n                  //         editingNode = node;\n                  //       }\n                  //       if(node.nodes){\n                  //         checkChildren(node.nodes);\n                  //       }\n                  //     }\n                  //   }\n                  //   checkChildren(nodes);\n                  // }\n                  \n                  // console.log('EditingNode to update:', editingNode);\n                  // // this.props.setState({\n                  // //   editingNode\n                  // // });\n                  \n                  \n                },\n                error: errr=>{\n                  \n                  console.error('Failed to /get');\n                    \n                  this.setState({\n                    fetchingRemote: false,\n                    fetchingRemoteError: true\n                  })\n                  \n                  // WINDOW.alert('Failed to /get');\n                }\n              });\n              \n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false,\n                fetchingRemoteError: true\n              })\n              \n            }\n            \n          });\n        }\n        \n        @autobind\n        fetchRemoteSingleNodeNew(nodePath){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true,\n                fetchingRemoteError: false\n              })\n              \n              \n              universe.$.ajax({\n                url: '/api/get',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({name: nodePath}),\n                success: result=>{\n                  // console.log('Got result from /get!', result);\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = universe.cJSON.parse(result);\n                  \n                  // console.log('Node Got:', node);\n                  \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  return resolve(node);\n              \n                },\n                error: err=>{\n                    \n                  this.setState({\n                    fetchingRemote: false,\n                    fetchingRemoteError: true\n                  })\n                }\n              });\n              \n              \n            } catch(err){\n              console.error('Failed getting local single node');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n        \n        @autobind\n        fetchRemoteSingleNode(nodeId){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true,\n                fetchingRemoteError: false\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                responseType: 'cjson',\n                                dataFilter: {\n                                  _id: nodeId\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // rebuild children w/o data \n                                      function cleanNode(node){\n                                        \n                                        // data included, NO PARENT/ROOT \n                                        \n                                        let newNode = miniverse.lodash.pick(node, [\n                                          '_id',\n                                          'nodeId',\n                                          'type',\n                                          'name',\n                                          '_path',\n                                          'data',\n                                          'placeholder',\n                                          'createdAt',\n                                          'updatedAt'\n                                        ])\n                                        newNode.nodes = [];\n                                        if(node.nodes){\n                                          node.nodes.forEach(tmpNode2=>{\n                                            newNode.nodes.push(cleanNode(tmpNode2));\n                                          })\n                                        }\n                                        return newNode;\n                                      }\n                                      \n                                      return cleanNode(inputNode);\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              if(typeof nodes == 'string'){\n                console.log('cjson returned for nodes');\n                nodes = universe.cJSON.parse(nodes);\n              } else {\n                console.log('NOT CJSON!');\n              }\n              \n              console.log('Nodes:', nodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                fetchingRemote: false,\n              })\n              \n              return resolve(nodes[0]);\n              \n            } catch(err){\n              console.error('Failed getting local single node');\n              \n              this.setState({\n                fetchingRemote: false,\n                fetchingRemoteError: true\n              })\n              \n            }\n            \n          });\n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n        \n            let name = WINDOW.prompt('Name (blank for random, replace % with UUID)','');\n            if(typeof name != 'string'){\n              console.log('canceled');\n              return false;\n            }\n            \n            name = name.trim();\n            \n            if(name == ''){\n              name = universe.uuidv4();\n            }\n            \n            name = name.replace(/\\%/g,()=>{\n              return universe.uuidv4();\n            });\n            \n            console.log('name:', name);\n            \n            \n            let type;\n            type = WINDOW.prompt('Type (types.second.default.code)','types.second.default.x');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forcePutNode(name, newNode);\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeRebuildMemoryRequest(){\n          return new Promise(async (resolve, reject) => {\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'rebuild_memory:Qmdsf892hf98h23',\n                            dataForAction: {\n                              type: 'rebuild_memory:0.0.2:local:123445',\n                              data: {\n                                skipWaitForResolution: false\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              \n              return resolve({\n                type: 'boolean:...',\n                data: true\n              });\n              \n            } catch(err){\n              console.error('Failed rebuildMemory');\n              \n              alert('Failed rebuildMemory');\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forcePutNode(name, nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', name, nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              universe.$.ajax({\n                url: '/api/put',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  name,\n                  type: nodeToSave.type, \n                  data: nodeToSave.data\n                }),\n                success: result=>{\n                  console.log('Got result from /api/put!', result);\n                  \n                  if(skipEvent !== true){\n                    try {\n                      universe.EE.emit('nodes-modified', '');\n                    }catch(err){\n                      console.error(err);\n                    }\n                  }\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = result;\n                  \n                  return resolve(node);\n              \n                },\n                error: errr=>{\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n            } catch(err){\n              console.error('Failed forcePutNode', err);\n              \n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async handleCreateInvite(){\n          \n          let inviteCode = universe.uuidv4();\n          \n          let name = WINDOW.prompt('Note for invite code?', '');\n          if(!name){\n            return false;\n          }\n          \n          let network = WINDOW.prompt('Network (public or test)', 'test');\n          if(network != 'public' && network != 'test'){\n            return false;\n          }\n          \n          inviteCode = WINDOW.prompt('Invite Code (should be unique!)', inviteCode);\n          if(!inviteCode){\n            return false;\n          }\n          \n          // TODO: \n          // - uniqueness check/constraint \n        \n          let newNode = {\n            name: universe.uuidv4(),\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324', // invite\n            data: {\n              name,\n              inviteCode,\n              network,\n              sourcePublicKey: null,\n              accepted: false,\n              uploadBytes: 0\n            }\n          }\n          \n          console.log('new invite node:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode);\n            \n          WINDOW.prompt('Invite Created!', inviteCode);\n            \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n            \n            let selectedNodes = this.props.state.selectedNodes || [];\n            \n            if(!selectedNodes.length){\n              WINDOW.alert('Select nodes using SHIFT key and clicking');\n              return false;\n            }\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            this.setState({\n              fetchingRemote: true\n            })\n            \n            for(let node of selectedNodes){\n                \n              // let node = JSON.parse(JSON.stringify(tmpNode));\n              console.log('Node to delete:', node);\n              \n              await universe.fetch('/api/remove',{\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  name: node.name,\n                  opts: {}\n                })\n              });\n              \n            }\n            \n            this.setState({\n              fetchingRemote: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null,\n              selectedNodes: []\n            })\n            \n            // Update nodes \n            this.fetchRemoteNodes();\n            \n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleClickNode(node, e){\n          \n          if(e.shiftKey){\n            // select multiple \n            let selectedNodes = this.props.state.selectedNodes || [];\n            let idx = selectedNodes.indexOf(node);\n            if(idx > -1){\n              selectedNodes.splice(idx,1);\n            } else {\n              selectedNodes.push(node);\n            }\n            \n            this.props.setState({\n              editingNode: null,\n              selectedNodes\n            })\n            \n            WINDOW.document.getSelection().removeAllRanges();\n            \n          } else {\n            \n            // build editingNode (without circular references) \n            \n            // fetch data from server! \n            // let nodeWithData = await this.fetchRemoteSingleNode(node._id);\n            let nodeWithData = await this.fetchRemoteSingleNodeNew(node.name);\n            // console.log('nodeWithData:', nodeWithData);\n            \n            function buildNode(tmpNode){\n              \n              let tmpReturnNode = {\n                // _id: tmpNode._id,\n                // nodeId: tmpNode.nodeId,\n                // _path: tmpNode._path,\n                name: tmpNode.name,\n                type: tmpNode.type,\n                data: tmpNode.data,\n                placeholder: tmpNode.placeholder,\n                nodes: [],\n                createdAt: tmpNode.createdAt,\n                updatedAt: tmpNode.updatedAt,\n              }\n              if(tmpNode.nodes){\n                for(let iTmpNode of tmpNode.nodes){\n                  tmpReturnNode.nodes.push(buildNode(iTmpNode));\n                }\n              }\n              return tmpReturnNode;\n            }\n            \n            let editingNode = buildNode(nodeWithData);\n            \n            this.props.setState({\n              editingNode,\n              selectedNodes: []\n            })\n          }\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              // function addChildren(id){\n              //   return new Promise(async (resolve,reject)=>{\n            \n              //     let nodes = [];\n              //       for(let filepath of Object.keys(allFiles)){\n              //         console.log('addChildren:', filepath);\n              //         let contents = allFiles[filepath];\n              //         if(filepath.indexOf('nodes/') !== 0){\n              //           // console.log('NOT NODE:', filepath);\n              //           continue;\n              //         }\n        \n              //         let parsed = jsonParse(filepath, contents);\n              //         if(parsed.nodeId == id){\n              //           // console.log('Matches ID:', parsed.nodeId, id);\n              //           let children = await addChildren(parsed._id);\n              //           parsed.nodes = children;\n              //           nodes.push(parsed);\n              //         } else {\n              //         // console.log('No Kids:', id, parsed.nodeId);\n              //       }\n      \n              //     }\n      \n              //     resolve(nodes);\n      \n              //   });\n              // }\n              \n              function addChildren(path){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  try {\n                      \n                    for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf(path) !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n                      let pathDepth = path.split('/').length;\n                      let filepathDepth = filepath.split('/').length;\n                      if(pathDepth == filepathDepth){\n                        // xyz.json at correct depth\n                        \n                        let parsed = jsonParse(filepath, contents);\n                        // if(parsed.nodeId == id){\n                          // console.log('Matches ID:', parsed.nodeId, id);\n                          let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                          parsed.nodes = children;\n                          nodes.push(parsed);\n                        // } else {\n                        //   // console.log('No Kids:', id, parsed.nodeId);\n                        // }\n                      }\n        \n        \n                    }\n                  }catch(err){\n                    console.error(err);\n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                // ZipNodes = await addChildren(null); // start at root, adds children recursively\n                ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  name: node.name,\n                  nodeId: null, // saving to root-level!\n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        name: tmpNode.name,\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('rebuilding memory on remote, after bulk updates');\n              // await this.makeRebuildMemoryRequest();\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              name: node.name || universe.uuidv4(),\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    name: tmpNode.name || universe.uuidv4(),\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter, depth){\n          depth = depth || 0;\n          let filters = this.state.text.split('>');\n          // reverse filters when checking\n          filters.reverse();\n          \n          nodes = universe.lodash.sortBy(nodes, 'name');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                  let levelName = node.name.split('.')[depth];\n                  \n                  let showChildren = true;\n                  if(this.state.hiding[node.name]){\n                    showChildren = false;\n                  }\n                \n                  const nodeMatchFunc = (node) => {\n                    // returns true if this node is a \"final match\" \n                    \n                    function checkNodeFilterMatch(tmpCheckNode, filter){\n                      let nodeFilterMatch;\n                      let tmpFilter;\n                      \n                      // default: path searching! \n                      // - no \":\" in search input \n                      if(filter.indexOf(':') === -1 && tmpCheckNode.name){\n                        tmpFilter = filter; //.split('p:')[1];\n                        if(tmpCheckNode.name && tmpFilter.length && pathMatch(tmpCheckNode.name, tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      \n                      \n                      // all (a:)\n                      if(filter.substring(0,2) == 'a:'){\n                        tmpFilter = filter.split('a:')[1];\n                        if(tmpCheckNode._id && tmpCheckNode._id.toString().includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(tmpCheckNode.type && tmpCheckNode.type.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(levelName && levelName.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // type (t:)\n                      if(filter.substring(0,2) == 't:' && tmpCheckNode.type){\n                        tmpFilter = filter.split('t:')[1];\n                        if(tmpCheckNode.type && tmpCheckNode.type.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // name (n:)\n                      if(filter.substring(0,2) == 'n:' && levelName){\n                        tmpFilter = filter.split('n:')[1];\n                        if(levelName && levelName.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // path (p:)\n                      if(filter.substring(0,2) == 'p:' && tmpCheckNode.name){\n                        tmpFilter = filter.split('p:')[1];\n                        if(tmpCheckNode.name && tmpFilter.length && pathMatch(tmpCheckNode.name, tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // data (d:) \n                      if(filter.substring(0,2) == 'd:'){\n                        tmpFilter = filter.split('d:')[1];\n                        if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // sibling type (st:) \n                      if(filter.substring(0,3) == 'st:' ){\n                        tmpFilter = filter.split('st:')[1];\n                        try {\n                          let findSiblingMatch = tmpCheckNode.parent.nodes.find(n=>{\n                            if(n.type && n.type.includes(tmpFilter)){\n                              return true;\n                            }\n                          });\n                          if(findSiblingMatch){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      // dirtyJson (obj matcher)\n                      if(filter.substring(0,1) == '{' && filter.substring(filter.length - 1) == '}'){\n                        try {\n                          let parsedJson = universe.dirtyJSON.parse(filter);\n                          if(universe.lodash.query([tmpCheckNode.data],parsedJson).length){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      return nodeFilterMatch;\n                    }\n                    \n                    // iterate through filters (TODO) \n                    // - find next parent in chain that matches \n                    let filtersClone = filters.concat();\n                    let lastFilter = filtersClone.shift().trim();\n                    \n                    let filtersToPass = lastFilter.split('&');\n                    \n                    let passedAll = true;\n                    for(let ftp of filtersToPass){\n                      \n                      ftp = ftp.trim();\n                      \n                      if(checkNodeFilterMatch(node, ftp)){\n                        // matches the last check, see if parents need to be checked \n                        if(filtersClone.length){\n                          // has a parent chain to check\n                          console.log('has parent chain to check!!');\n                          // return true;\n                        } else {\n                          // no other filters, dont need to check parent chain \n                          // return true;\n                        }\n                      } else {\n                        passedAll = false;\n                      }\n                    }\n                    \n                    if(passedAll){\n                      return true;\n                    }\n                    \n                    return null;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = (filters.length && filters[0].length) ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  // DO NOT SHOW CHILDREN (TODO: checkbox toggle?) \n                  if(!this.state.showChildren){\n                    if(hasFilter && parentInFilter && !childMatch && !nodeMatch){\n                      // console.log('Not showing cuz parentInFilter w/o this or child matching');\n                      return undefined;\n                    }\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  let nodeTypeFirst = node.type ? node.type.split(':')[0]:null;\n                  try {\n                    switch(nodeTypeFirst){\n                      case 'react_component':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      case 'folder':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'node_repo_on_github':\n                        tooltip = node.data.repo;\n                        break;\n                        \n                      case 'app_base':\n                        tooltip = [node.data.name, node.data.appId].join(' - ');\n                        break;\n                        \n                      case 'platform_nodes':\n                        tooltip = node.data.platform;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  let rowStyle = {whiteSpace:'nowrap'};\n                  if(this.props.state.editingNode && this.props.state.editingNode.name == node.name){\n                    rowStyle.fontWeight = 'bold';\n                  }\n                  \n                  if(this.props.state.selectedNodes && this.props.state.selectedNodes.find(n=>{return n.name == node.name})){\n                    rowStyle.background = 'red';\n                  }\n                  \n                  return (\n                    <div key={levelName}>\n                      <div style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              <span style={rowStyle}>\n                                {\n                                  (node.nodes && node.nodes.length) ?\n                                    <span onClick={e=>{this.toggleHide(node.name);e.preventDefault();return false;}} style={{width:'12px',display:'inline-block'}}>{showChildren ? '-':'+'}</span>\n                                  :<span style={{width:'12px',display:'inline-block'}}>&nbsp;</span>\n                                }\n                                <span onClick={e=>this.handleClickNode(node, e)} >{levelName} <span style={{opacity:\"0.7\"}}>[{node.nodes.length}] ({node.type})</span></span>\n                              </span>\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      {\n                        (!(node.nodes && node.nodes.length) || !showChildren) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes, parentInFilter || nodeMatch, depth+1)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        @autobind\n        toggleHide(name){\n          let hiding = this.state.hiding;\n          if(hiding[name]){\n            hiding[name] = false;\n          } else {\n            hiding[name] = true;\n          }\n          console.log('Hiding:', hiding);\n          this.setState({hiding});\n        }\n        \n        @autobind\n        async handleSelectedFiles(event){\n          \n          // this.setState({files: event.target.value});\n          \n          console.log('event files:', event.target.files, event.target);\n          let files = await getFiles(event.target.files);\n          console.log('FILES:', files);\n          \n          if(!this.props.state.editingNode){\n            WINDOW.alert('Choose a parent directory to upload files to');\n            \n            // reset input\n            this.setState({\n              files: ''\n            });\n            return false;\n          }\n          \n          let parentDirectory = this.props.state.editingNode.name;\n          \n          parentDirectory = WINDOW.prompt('Parent directory for file upload', parentDirectory);\n          if(!parentDirectory){\n            // reset input\n            this.setState({\n              files: ''\n            });\n            return false;\n          }\n          \n          this.setState({\n            isUploading: true\n          });\n          \n          for(let file of files){\n            \n            // let file = files[idx];\n            // console.log('file:', file); //, idx);\n            // Upload each file to a new path \n            // - TODO: findAndUpdateOrCreate \n            \n            // Search remote nodes \n            // - services: create_if_cant_find\n            \n            let parentRegexp = '^' + parentDirectory.split('.').join('\\\\.') + '\\\\.[-\\\\w]+$';\n            \n            let response = await universe.$.ajax({\n              url: '/api/put_via_find_and_update_or_create',\n              method: 'post',\n              contentType: 'application/json',\n              data: JSON.stringify({\n                type: 'types.second.default.api_put_via_find_and_update_or_create',\n                data: {\n                  where: {\n                    name: {\n                      $regexp: parentRegexp //'^app\\\\.second\\\\.sample_pwa\\\\.static\\\\.[-\\\\w]+$', // so many damn slashes\n                    },\n                    'data.filename': file.name\n                  },\n                  put: {\n                    name: [parentDirectory, universe.uuidv4()].join('.'), // ignored if found above! \n                    type: 'types.second.default.static_file',\n                    data: {\n                      filename: file.name,\n                      mimetype: file.type,\n                      encoded: 'base64',\n                      base64: file.base64StringFile\n                    }\n                  }, // name is ignored!!\n                  opts: {\n                    multiple: false\n                  }\n                }\n              })\n            });\n            \n            console.log('response', response);\n            \n          }\n          \n          this.setState({\n            files: '',\n            isUploading: false\n          });\n  \n        }\n        \n        render(){\n          \n          let nodes = this.props.state.nodes || [];\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\" style={{position:'relative'}}>\n              \n              <div style={{position:'sticky', top: '0px', borderBottom:'1px solid #ccc', background: '#eee', zIndex:'1', width:'100%'}}>\n                \n                {\n                  !this.state.pastable ? '':\n                  <div>\n                    <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                    <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                    <button className=\"button is-pulled-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                  </div>\n                }\n                \n                <strong>\n                  Nodes\n                  \n                  &nbsp;\n                  \n                  {/*\n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteNodes}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  */}\n                  \n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteNodes}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  \n                  {\n                    !this.state.fetchingRemoteError ? '':\n                    <button className={\"button is-small is-danger \"}>\n                      <span className=\"icon is-small\">\n                        <i className=\"fas fa-exclamation\"></i>\n                      </span>\n                    </button>\n                  }\n                  \n                  <button className={\"button is-small \" + (this.state.isUploading ? 'is-loading':'')} onClick={this.handleUploadFile}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-upload \"></i>\n                    </span>\n                    <input type=\"file\" name=\"\" id=\"\" onChange={this.handleSelectedFiles} value={this.state.files} style={uploadInputStyle} multiple />\n                  </button>\n                  \n                  <div className=\"dropdown is-hoverable is-right is-pulled-right\">\n                    <div className=\"dropdown-trigger\">\n                      <button className=\"button is-small\">\n                        <span className=\"icon is-small\">\n                          <i className=\"fa fa-angle-down\"></i>\n                        </span>\n                      </button>\n                    </div>\n                    <div className=\"dropdown-menu\">\n                      <div className=\"dropdown-content\">\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleNewId}>\n                          Copy New UUID to Clipboard\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleNewNode}>\n                          New Node (path, type)\n                        </a>\n                        \n                        {\n                          (this.props.state.selectedNodes && this.props.state.selectedNodes.length) ?\n                          <a className=\"dropdown-item\" onClick={this.handleDelete}>\n                            Delete Selected\n                          </a>:''\n                        }\n                        \n                        {/*\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleCreateInvite}>\n                          Create Invite\n                        </a>\n                        \n                        \n                        <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                          Insert Node By Paste\n                        </a>\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                          Import Bundle (.Zip, or GitHub) \n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                          Encrypt String\n                        </a>\n                        \n                        \n                        <div className=\"dropdown-divider\"></div>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                          Insert Many for Test\n                        </a>\n                        \n                        */}\n                        \n                      </div>\n                    </div>\n                  </div>\n                  \n                </strong>\n                \n                \n                <div className=\"field has-addons\">\n                  <div className=\"control is-expanded\">\n                    <input \n                      className=\"input\" \n                      value={this.state.text} \n                      onChange={e=>this.setState({text:e.target.value})} \n                      placeholder=\"path e.g. types.standard\" \n                    />\n                  </div>\n                  <div className=\"control\">\n                    <input \n                      type=\"checkbox\"\n                      title=\"Show Children\"\n                      className=\"checkbox\" \n                      checked={this.state.showChildren} \n                      onChange={e=>this.setState({showChildren: !this.state.showChildren})} \n                      style={{width:'40px'}}\n                    />\n                  </div>\n                </div>\n                \n              </div>\n              \n              <div style={{position:'relative'}}>\n                {this.renderNodes(nodes)}\n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      let uploadInputStyle = {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        opacity: '0.00001'\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "note": "/dev left side"
  },
  "blobdata": null,
  "createdAt": "2019-03-05T06:43:09.722Z",
  "updatedAt": "2019-03-17T21:50:26.544Z",
  "nodes": []
}