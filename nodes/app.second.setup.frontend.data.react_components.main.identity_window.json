{
  "type": "types.second.default.react_component.js",
  "name": "app.second.setup.frontend.data.react_components.main.identity_window",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div style={{display:'none'}}>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      \n      let horizonPossible = {\n        'idtest:': 'https://horizon-testnet.stellar.org',\n        'test:': 'https://horizon-testnet.stellar.org',\n        'id:': 'https://horizon.stellar.org',\n        'second:': 'https://horizon.stellar.org'\n      }\n      \n      function getIpfsHash(str){\n        // Not used, using createIpfsHash instead \n        return new Promise(async (resolve,reject)=>{\n          \n          let buf = universe.Buffer.from(str,'utf8');\n          let mhash = await universe.MultiHash.getMultiHash(buf);\n          \n          resolve(mhash);\n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          // try {\n          //   thisIpfs.files.add(new thisIpfs.types.Buffer(str, 'utf8'), {\n          //     onlyHash: true\n          //   }, (err, res)=>{\n          //     console.log('localIpfsHash result:', err, res);\n          //     console.log('Hash:', res[0].hash);\n          //     resolve(res[0].hash);\n          //   });\n          // }catch(err){\n          //   console.error('ipfs buffer failure:', err)\n          //   reject();\n          // }\n          \n        });\n      }\n      \n      function getIpfsValue(hash){\n        console.log('getIpfsValue:', hash);\n        \n        return new Promise(async (resolve,reject)=>{\n          \n          console.log('fetching ipfs hash:', hash); \n          \n          // just use ipfs.io \n          universe.fetch('https://ipfs.io/ipfs/' + hash)\n          .then(function(res){\n            console.log('from IPFS.io:', res);\n            return res.text();\n          })\n          .then(function(textResult){\n            resolve(textResult);\n          })\n          .catch(function(){\n            console.error('Failed loading IPFS hash from ipfs.io');\n            reject();\n          })\n          \n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          // try {\n          //   thisIpfs.files.cat(hash, (err, res)=>{\n          //     console.log('localIpfsValue result:', err, res);\n          //     // console.log('Hash:', res[0].hash);\n          //     resolve(res.toString());\n          //   });\n          // }catch(err){\n          //   console.error('ipfs value failure:', err)\n          //   reject();\n          // }\n          \n        });\n      }\n      \n            \n      // https://lollyrock.com/articles/nodejs-encryption/\n      function encryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var cipher = universe.crypto.createCipher(algorithm,password)\n          var crypted = cipher.update(text,'utf8','hex')\n          crypted += cipher.final('hex');\n          console.log('crypted', text, crypted);\n          resolve(crypted);\n        });\n      }\n      function decryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var decipher = universe.crypto.createDecipher(algorithm,password)\n          var dec = decipher.update(text,'hex','utf8')\n          dec += decipher.final('utf8');\n          resolve(dec);\n        });\n      }\n      \n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          let routeProtocol = this.props.state.UsernamePassphraseNode.data.network == 'test' ? 'test://':''\n          \n          let routeHost = routeProtocol + this.props.state.UsernamePassphraseNode.data.username;\n          \n          this.state = {\n            // stellarKey: '',\n            // routeText: 'id://nick/test1',\n            stellarKey: this.props.state.UsernamePassphraseNode.data.passphrase, \n            defaultRouteHost: routeHost,\n            routeHost, // omits trailing '/' if routeText is empty\n            sendMessageHost: routeHost,\n            routeText: '', // should default to \"/\" or be in routeHost?\n            isSearching: false,\n            dataValue: '',\n            canParse: true,\n            isSaving: false,\n            usernameClaimable: false,\n            usernameOwnedByMe: true,\n            \n            tabsMainPossible: [\n              ['route','Routes'], \n              ['send_message','Send Message'],\n              ['receive_messages','Receive Messages']\n            ],\n            tabsMainSelected: 'route', \n            \n            msgValue: '',\n            outgoingMessages: [],\n            \n            fromRouteHost: this.props.state.UsernamePassphraseNode.data.passphrase, \n            toRouteHost: routeProtocol,\n            transferAmount: '0.0',\n            \n            gettingBalance: [false,false],\n            balanceOf: [null,null],\n            \n            connectedColor: 'yellow',\n            \n            routesRemaining: 7 // TODO: calculate from stellar balance! \n          }\n          \n          this.setupWebsocket();\n          \n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded interface', this);\n            \n          // PeerJs server \n          const script = WINDOW.document.createElement(\"script\");\n          script.src = \"https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.16/peer.min.js\";\n          script.async = true;\n          WINDOW.document.body.appendChild(script);\n            \n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n          \n          this.startup();\n          \n        }\n        \n        @autobind\n        async startup(){\n          \n          // await this.loadComponents();\n          \n          this.updateRouteFullPath();\n          \n          this.checkIpfsConnected();\n          \n          this.fetchOutgoingMessages(); // local\n          \n        }\n        \n        @autobind\n        setupWebsocket(){\n          \n          console.log('setupWebsocket');\n          \n          // universe.sharedServices.socketioClient = universe.require('socket.io-client')\n          // var io = universe.sharedServices.socketioClient;\n          let socket = WINDOW.io(); // same address? \n          WINDOW.socketioClient = socket;\n          \n          socket.on('connect', async ()=>{\n            console.log('Connected websocket (listening)!');\n            \n            // Run \"register\" event when button is pressed \n            universe.setTimeout(()=>{\n              console.log('Proxy setup');\n              \n              // if(!WINDOW.confirm('connect websocket?')){\n              //   return false;\n              // }\n              \n              this.emitBrowserProxySetup();\n              \n            },1000);\n            \n          });\n          \n          \n          socket.on('proxied-request', async (RequestNode, responseFunc)=>{\n          \t// let requestId = uuidv4();\n           //  console.log('RequestNode:', RequestNode);\n           \n            console.log('Got a proxied request from server', RequestNode);\n          \n            responseFunc({\n              type: 'received_boolean:Qmtesting',\n              data: true\n            });\n            \n            \n            // responseFunc('Response from browser2!!!!');\n            this.processSitutationFromExternal(RequestNode);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        emitBrowserProxySetup(){\n        \n          var passwordPair = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n          \n          let sourcePublicKey = passwordPair.publicKey();\n          let endpoint = this.props.state.UsernamePassphraseNode.data.username;\n          let nonce = Date.now().toString();\n          let sig = passwordPair.sign(sourcePublicKey + endpoint + nonce).toString('base64'); //fileValue);\n          \n          console.log('sig:', sig, typeof sig);\n          \n          let SetupNode = {\n            type: 'browser_proxy_setup:Qmtesting',\n            data: {\n              sourcePublicKey,\n              endpoint,\n              nonce,\n              sig\n            }\n          }\n          \n          console.log('SetupNode for browser-proxy-setup', SetupNode);\n          \n          // TODO: check if connected to websocket \n          \n          WINDOW.socketioClient.emit('browser-proxy-setup', SetupNode, async (ResponseNode)=>{\n            console.log('browser-proxy-setup result:', ResponseNode);\n            \n            // Update ipfs Hash for myself (if different, or unset) \n            \n            // Load existing \n            let routePath = (this.props.state.UsernamePassphraseNode.data.network == 'test' ? 'test://':'second://') + this.props.state.UsernamePassphraseNode.data.username;\n            let routeInfo = await this.parseRoute(routePath);\n            let routeData;\n            let currentRouteData;\n            try {\n              currentRouteData= await this.loadIdentityRoute(routeInfo.protocol, routeInfo.pairForIdentity.publicKey(), routeInfo.lookupPath);\n            }catch(err){\n              console.error('Failed finding currentRouteData', err)\n              currentRouteData = undefined;\n            }\n            \n            console.log('currentRouteData:', currentRouteData);\n            \n            if(currentRouteData){\n              try {\n                routeData = JSON.parse(currentRouteData);\n                routeData.data.urls['message-drop'] = ResponseNode.data.proxyUrl\n              }catch(err){\n                console.error('Unable to parse existing routeData', routeData);\n                routeData = null;\n              }\n            }\n            \n            if(!routeData){\n              // Unable to find valid routeData!\n              console.error('Failed to lookup my default route info');\n              routeData = {\n                \"type\": \"\",\n                \"data\": {\n                  \"urls\": {\n                    \"message-drop\": ResponseNode.data.proxyUrl\n                  }\n                }\n              };\n              if(!this.props.state.receivingEnabled){\n                console.log('Receiving disabled');\n                this.props.setState({\n                  waitingForEnabled: true\n                });\n                return false;\n              }\n            }\n            \n            this.props.setState({\n              waitingForEnabled: false,\n              receivingEnabled: true\n            });\n            \n            let stringifiedData = JSON.stringify(routeData,null,2);\n            \n            console.log('routeData to save', routePath, routeData);\n            if(stringifiedData == currentRouteData){\n              console.log('No need to update, same proxy routes');\n              return;\n            }\n            this.addRouteData(stringifiedData, routePath);\n            \n            \n          });\n        }\n        \n        @autobind\n        async processSitutationFromExternal(RequestNode){\n          \n          console.log('processSitutationFromExternal', RequestNode);\n          \n          // TODO: validate RequestNode type \n          if(!RequestNode || !RequestNode.data || RequestNode.type != 'signed_message:Qmtesting'){\n            console.error('Missing expected incoming data for RequestNode, ignoring');\n            return false;\n          }\n          \n          let messagesIncoming = this.props.state.messagesIncoming || [];\n          \n          messagesIncoming.push({\n            IncomingNode: RequestNode,\n            createdAt: Date.now()\n          });\n          \n          this.props.setState({\n            messagesIncoming\n          });\n          \n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'PartialReceiveMessagesComponent'\n          ];\n          \n          for(let componentInternalId of components){\n            try {\n                \n              let Component = await this.props.loadComponent({\n                internalId: componentInternalId\n              });\n              let obj = {};\n              obj[componentInternalId] = Component;\n              this.setState(obj)\n            }catch(err){\n              console.error(\"Failed loading component:\",componentInternalId);\n            }\n          }\n          \n        }\n        \n        @autobind\n        async logout(){\n          \n          // remove all data \n          // root nodes that aren't the app \n          await universe.sharedServices.logout();\n          \n          this.props.setState({\n            renderMain: false,\n            UsernamePassphraseNode: null,\n            waitingForEnabled: true,\n            receivingEnabled: false\n          });\n          \n          // WINDOW.location.reload();\n          \n        }\n        \n        @autobind\n        async checkIpfsConnected(){\n          \n          console.log('checkIpfsConnected');\n          \n          let connectedColor = 'yellow';\n          \n          this.setState({\n            connectedColor\n          });\n          \n          let response = await universe.fetch('/ipfs-connected',{\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\", // charset=utf-8\n            }\n          })\n          console.log('Response:', response);\n          \n          let responseJson = await response.json();\n          \n          console.log('responseJson', responseJson);\n          \n          if(responseJson.data){\n            connectedColor = 'green';\n          } else {\n            connectedColor = 'red';\n          }\n          \n          this.setState({\n            connectedColor\n          });\n          \n          \n        }\n        \n        @autobind\n        async setupOrbitDb(){\n          \n          console.log('setupOrbitDb');\n          \n          // setup an orbit db \n          // - stored in localstorage? \n                    \n          // OrbitDB uses Pubsub which is an experimental feature\n          // and need to be turned on manually.\n          // Note that these options need to be passed to IPFS in\n          // all examples even if not specfied so.\n          var ipfsOptions = {\n              repo: '/orbitdb/examples/browser/new/ipfs/0.27.3',\n              start: true,\n              EXPERIMENTAL: {\n                pubsub: true,\n              },\n              config: {\n                Addresses: {\n                  Swarm: [\n                    // Use IPFS dev signal server\n                    // '/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star',\n                    '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n                    // Use local signal server\n                    // '/ip4/0.0.0.0/tcp/9090/wss/p2p-webrtc-star',\n                  ]\n                },\n              }\n          }\n          \n          // Create IPFS instance\n          const ipfs = new WINDOW.Ipfs(ipfsOptions)\n          \n          console.log('Got ipfs');\n          \n          try {\n          \n            ipfs.on('error', function(e){console.error(e)})\n            ipfs.on('init', function(e){console.log('init', e)})\n            ipfs.on('start', function(e){console.log('start', e)})\n            ipfs.on('ready', async () => {\n              \n              console.log('Ready');\n              \n              const orbitdb = new WINDOW.OrbitDB(ipfs)\n              WINDOW.odb = orbitdb;\n            \n              // Create / Open a database\n              const db = await orbitdb.log('hello')\n              await db.load()\n              \n              console.log('orbit log db loaded');\n              WINDOW.odblog = db;\n            \n              // Listen for updates from peers\n              db.events.on('replicated', (address) => {\n                console.log(db.iterator({ limit: -1 }).collect())\n              })\n            \n              // Add an entry\n              const hash = await db.add('world')\n              console.log('hash:', hash)\n            \n              // Query\n              const result = db.iterator({ limit: -1 }).collect()\n              console.log('query:', JSON.stringify(result, null, 2))\n            })\n          }catch(err){\n            console.error(err);\n          }\n          \n\n        }\n        \n        @autobind\n        updateRouteFullPath(){\n          \n          let {\n            routeHost,\n            routeText\n          } = this.state;\n          \n          routeText = routeText.trim();\n          \n          if(!routeText.length){\n            // routeHost = routeHost;\n            routeText = '/';\n          } else {\n            if(routeText.substring(0,1) != '/'){\n              routeText = '/' + routeText;\n            }\n          }\n          \n          let routeFullPath = routeHost + routeText;\n          \n          console.log('routeFullPath', routeFullPath);\n          \n          this.setState({\n            routeFullPath\n          })\n        }\n        \n        @autobind\n        handleSearchKeyDown(e){\n        \n          if(e.key && e.key.toLowerCase() == 'enter'){\n            \n            this.handleSearch();\n            \n          } \n        }\n        \n        @autobind\n        handleTextareaKeydown(e){\n        \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              canParse: true\n            });\n            \n          }catch(err){\n            this.setState({\n              canParse: false\n            });\n          }\n          \n          this.setState({\n            isSending: false\n          })\n          \n        } \n        \n        @autobind\n        async parseRoute(routeUrl){\n          \n          // parse route \n          // - if no \":\" then assume PubNet \n          \n          // default to this route\n          if(routeUrl.indexOf(':') === -1){\n            routeUrl = 'second://' + routeUrl;\n          }\n          \n          let parser;\n          if(typeof WINDOW != 'undefined'){\n            parser = WINDOW.document.createElement('a');\n            parser.href = routeUrl; \n          } else {\n            const { URL } = universe.require('url');\n            parser = new URL(routeUrl);\n          }\n          \n          let protocol = parser.protocol;\n          switch(protocol){\n            case 'http:':\n            case 'https:':\n            case 'id:':\n              protocol = 'second:'; \n              // no break!! \n            case 'idtest:':\n            case 'test:':\n            case 'second:':\n              parser.protocol = 'http:';\n              break;\n            \n            default:\n              WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n              console.error('protocol:', parser.protocol);\n              return false;\n          }\n          \n          let baseIdentity = parser.host;\n          let subName = parser.username || '';\n          let fullName = subName.length ? `${subName}@${baseIdentity}` : baseIdentity;\n          let password = parser.password.length ? parser.password : '';\n          let routePath = parser.pathname || '/'; // parser.pathname ? parser.pathname.slice(1) : ''; // OLD removed leading slash! \n          \n          console.log('Parsed route:', {baseIdentity, subName, password, routePath});\n        \n          switch(protocol){\n            case 'id:':\n            case 'second:':\n              universe.StellarSdk.Network.usePublicNetwork();\n              break;\n            case 'idtest:':\n            case 'test:':\n              universe.StellarSdk.Network.useTestNetwork();\n              break;\n            default:\n              console.error('Invalid protocol');\n              return;\n          }\n          \n          let usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n          console.log('usernameSeed', usernameSeed);\n          \n          var pairForIdentity = universe.StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n          \n          // // route path ALWAYS starts with a slash \n          // // - reserving non-slash for zone-like files \n          // if(routePath.length == 0){\n          //   routePath = '/';\n          // }\n          \n          let lookupPath = baseIdentity + '|' + subName + '|' + password + '|' + routePath;\n          \n          let lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n          \n          return {\n            pairForIdentity,\n            parser,\n            protocol,\n            baseIdentity,\n            subName,\n            fullName,\n            password,\n            routePath,\n            lookupPath,\n            lookupPathHash\n          }\n          \n        }\n        \n        @autobind\n        async loadIdentityRoute(protocol, pubKey, route){\n          \n          try {\n              \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[protocol]);\n              \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(pubKey)\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              return false;\n            }\n            \n            let lookupPathHash = universe.crypto.createHash('sha256').update(route).digest('hex'); \n            \n            console.log('lookupPathHash', lookupPathHash);\n      \n            // get the ipfs value \n            let valueIpfsHash = await identityAccount.data({key: lookupPathHash})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              console.error('ipfs error', err);\n              return null;\n            })\n            \n            console.log('Data Result:', valueIpfsHash);\n            if(!valueIpfsHash){\n              // throw 'Missing data result'\n              console.error('Missing data result');\n              return undefined;\n            }\n            \n            // Load IPFS data \n            let ipfsData;\n            try {\n              ipfsData = await getIpfsValue(valueIpfsHash);\n            } catch(err){\n              console.error('Failed to find default ipfsData for proxy route');\n              ipfsData = undefined;\n            }\n            \n            console.log('ipfsData:', ipfsData);\n            \n            return ipfsData;\n            \n          }catch(err){\n            console.error('Failed loadIdentityRoute:', err);\n            return undefined;\n          }\n          \n        }\n        \n        @autobind\n        async handleSearch(){\n          console.log('searching');\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.setState({\n            isSearching: true,\n            failedSearch: false\n          });\n          \n          try {\n            \n            // Load message-input node for username \n            let routeInfo = await this.parseRoute(this.state.routeFullPath);\n            if(!routeInfo){\n              this.setState({\n                isSearching: false,\n                failedSearch: 'Invalid route'\n              });\n              return false;\n            }\n            \n            // Check username \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[routeInfo.protocol]);\n            \n            this.setState({\n              usernameClaimable: false,\n              usernameOwnedByMe: false\n            });\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(routeInfo.pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              // WINDOW.alert('failed loading idenity');\n              \n              this.setState({\n                usernameClaimable: true\n              });\n            \n              throw 'Failed loading identity'\n            }\n            \n            // owned by me? \n            var pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n            var pairSourcePublicKey = pairSource.publicKey();\n            for(let signer of identityAccount.signers){\n              if(signer.public_key == pairSourcePublicKey){\n                this.setState({\n                  usernameOwnedByMe: true\n                })\n              }\n            }\n            \n            \n            // Load route data \n            let ipfsData = await this.loadIdentityRoute(routeInfo.protocol, routeInfo.pairForIdentity.publicKey(), routeInfo.lookupPath);\n            \n            if(!ipfsData){\n              // Unable to find valid \n              console.error('Failed to lookup connection info');\n              this.setState({\n                isSearching: false,\n                failedSearch: 'Failed to find user connection info (1)'\n              })\n              return false;\n            }\n            \n            console.log('ipfsData:', ipfsData);\n            \n            // TODO: handle decryption automatically with passwords? \n            \n            let dec = ipfsData;\n            let actualValue = dec;\n            if(routeInfo.password){\n              console.log('had password'); \n              dec = await decryptToString(ipfsData, routeInfo.password + routeInfo.routePath);\n              console.log('decrypted1:', dec);\n              actualValue = await getIpfsValue(dec);\n              dec = await decryptToString(actualValue, routeInfo.password + routeInfo.routePath);\n              actualValue = dec;\n            }\n            \n            console.log('decrypted-same:', dec == actualValue ? true:false, dec, actualValue);\n            \n            \n            // expecting a Node type to be returned \n            let nodeData;\n            try {\n              nodeData = JSON.parse(actualValue);\n            }catch(err){\n              console.error('unable to parse nodedata');\n            }\n            \n            console.log('Final nodeData:', nodeData);\n            \n            this.setState({\n              dataValue: actualValue\n            });\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed searching', err);\n            \n            this.setState({\n              failedSearch: true\n            })\n          \n          }\n          \n          this.setState({isSearching: false});\n          \n        }\n        \n        @autobind \n        async getBalance(idx){\n          // 0 = From \n          // 1 = To \n          \n          this.setState(state=>{\n            state.gettingBalance[idx] = true;\n            state.balanceOf[idx] = null;\n            return state;\n          });\n          \n          let pubKey;\n          \n          // get protocol from \"To\" person \n          let routeInfo = await this.parseRoute(this.state.toRouteHost);\n          if(!routeInfo){\n            WINDOW.alert('Invalid username protocol to send to');\n            this.setState(state=>{\n              state.gettingBalance[idx] = false;\n              return state;\n            });\n            return false;\n          }\n          \n          \n          let stellarServer = new universe.StellarSdk.Server(horizonPossible[routeInfo.protocol]);\n          \n          if(idx == 0){\n            \n            // From (private key only) \n            var pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.fromRouteHost);\n            pubKey = pairSource.publicKey();\n            \n          } else {\n            \n            // To (username and protocol) \n            pubKey = routeInfo.pairForIdentity.publicKey();\n            \n          }\n          \n          \n          let targetAccount;\n          try {\n            targetAccount = await stellarServer.loadAccount(pubKey)\n          }catch(err){\n            console.error('Failed getting targetAccount', err);\n            this.setState(state=>{\n              state.gettingBalance[idx] = false;\n              return state;\n            });\n            return false;\n          }\n          \n          console.log('targetAccount:', targetAccount);\n          \n          this.setState(state=>{\n            state.balanceOf[idx] = targetAccount.balances[0].balance;\n            state.gettingBalance[idx] = false;\n            return state;\n          });\n          \n        }\n          \n        \n        @autobind \n        async handleTransfer(){\n          \n          // stellar key should be pasted in \n          let fromStellarKey = this.state.fromRouteHost;\n          let toRouteHost = this.state.toRouteHost;\n          let transferAmount = this.state.transferAmount;\n            \n          this.setState({\n            isTransferring: true,\n            failedTransfer: false\n          });\n          \n          try {\n            \n            if(parseFloat(transferAmount) < 0){\n              this.setState({\n                isTransferring: false,\n                failedTransfer: 'Invalid transfer Amount'\n              });\n              return false;\n            }\n            \n            // Load username (no routePath expected!) \n            let routeInfo = await this.parseRoute(this.state.toRouteHost);\n            if(!routeInfo){\n              this.setState({\n                isTransferring: false,\n                failedTransfer: 'Invalid username to send to (1)'\n              });\n              return false;\n            }\n            \n            if(routeInfo.routePath.length && routeInfo.routePath != '/'){\n              this.setState({\n                isTransferring: false,\n                failedTransfer: 'Invalid username to send to (2)'\n              });\n              return false;\n              \n            }\n            \n            console.log('toRouteInfo:', routeInfo);\n            \n            // Check username \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[routeInfo.protocol]);\n            \n            let targetAccount;\n            try {\n              targetAccount = await stellarServer.loadAccount(routeInfo.pairForIdentity.publicKey())\n              console.log('targetAccount:', targetAccount);\n            }catch(err){\n              console.error('Failed getting targetAccount', err);\n              // WINDOW.alert('failed loading idenity');\n              \n              this.setState({\n                isTransferring: false,\n                failedTransfer: 'Failed finding target account (doesnt exist on blockchain)'\n              });\n            \n              return false;\n            }\n            \n            \n            var pairSource = universe.StellarSdk.Keypair.fromSecret(fromStellarKey);\n            // var pairSourcePublicKey = pairSource.publicKey();\n            \n            let sourceAccount;\n            try {\n              sourceAccount = await stellarServer.loadAccount(pairSource.publicKey())\n              console.log('sourceAccount:', sourceAccount);\n            }catch(err){\n              console.error('Failed getting sourceAccount', err);\n              // WINDOW.alert('failed loading idenity');\n              \n              this.setState({\n                isTransferring: false,\n                failedTransfer: 'Failed finding source account (doesnt exist on blockchain)'\n              });\n            \n              return false;\n            }\n            \n            \n            // Start building the transaction for manageData update\n            let transaction = new universe.StellarSdk.TransactionBuilder(sourceAccount)\n              .addOperation(universe.StellarSdk.Operation.payment({\n                destination: routeInfo.pairForIdentity.publicKey(),\n                // Because Stellar allows transaction in many currencies, you must\n                // specify the asset type. The special \"native\" asset represents Lumens.\n                asset: universe.StellarSdk.Asset.native(),\n                amount: transferAmount\n              }))\n              // A memo allows you to add your own metadata to a transaction. It's\n              // optional and does not affect how Stellar treats the transaction.\n              // .addMemo(universe.StellarSdk.Memo.text('Test'))\n              .build();\n  \n            // Sign the transaction to prove you are actually the person sending it.\n            // transaction.sign(routeInfo.pairForIdentity); // targetKeys\n            transaction.sign(pairSource); // sourceKeys\n  \n            // send to stellar network\n            let stellarResult = await stellarServer.submitTransaction(transaction)\n            .then(function(result) {\n              console.log('Stellar payment Success! Results:'); //, result);\n              return result;\n            })\n            .catch(function(error) {\n              console.error('Stellar Something went wrong (failed payment)!', error);\n              // If the result is unknown (no response body, timeout etc.) we simply resubmit\n              // already built transaction:\n              // server.submitTransaction(transaction);\n              return null;\n            });\n  \n            // console.log('stellarResult', stellarResult);\n  \n            if(!stellarResult){\n              console.error('Failed stellar payment');\n              throw 'Failed stellar payment'\n            }\n            \n            console.log('Payment succeeded!', stellarResult);\n            \n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed transfer', err);\n            \n            this.setState({\n              failedTransfer: true\n            })\n          \n          }\n          \n          this.setState({isTransferring: false});\n          \n        }\n        \n        \n        @autobind\n        async handleAddRouteData(e){\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          let nodeData = this.state.dataValue; // expecting a string, should be JSON.parse'able \n          \n          // try {\n          //   JSON.parse(nodeData);\n          // }catch(err){\n          //   WINDOW.alert('Invalid JSON specified');\n          //   return false;\n          // }\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.addRouteData(nodeData, routeFullPath);\n        }\n        \n        \n        \n        @autobind\n        async addRouteData(nodeData, routeFullPath){\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          this.setState({\n            isSaving: true,\n            failedSaving: false\n          });\n          \n          try {\n              \n            let routeInfo = await this.parseRoute(routeFullPath);\n            if(!routeInfo){\n              this.setState({\n                isSaving: false,\n                failedSaving: 'Invalid route'\n              });\n              return false;\n            }\n              \n            // encrypt data using password\n            if(routeInfo.password){\n              nodeData = await encryptToString(nodeData, routeInfo.password+routeInfo.routePath);\n            }\n            \n            console.log('encrypted NodeData:', nodeData);\n            \n            // create IPFS hashes of nodeData \n            let ipfsHashOfData = await this.createIpfsHashOnSecond(nodeData); // TODO \n            \n            console.log('ipfsHashOfData:', ipfsHashOfData);\n            \n            let encryptedDataToSave,\n              ipfsHashOfEncryptedData;\n            if(routeInfo.password){\n              // encrypt the ipfs hash using password+path \n              console.log('Using password for encryption');\n              encryptedDataToSave = await encryptToString(ipfsHashOfData, routeInfo.password+routeInfo.routePath); // TODO\n              ipfsHashOfEncryptedData = await this.createIpfsHashOnSecond(encryptedDataToSave); \n              console.log('ipfsHashOfEncryptedData:', ipfsHashOfEncryptedData);\n            }\n            \n            \n            // Add files and pin data to IPFS \n            // TODO \n            \n            \n            // Write to Stellar \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[routeInfo.protocol]);\n            \n            // multi-sig address for updating \n            var pairForWrite = universe.StellarSdk.Keypair.fromSecret(stellarKey);\n            \n            console.log('pairForIdentity', routeInfo.pairForIdentity);\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(routeInfo.pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              WINDOW.alert('failed loading idenity');\n              throw 'Failed loading identity'\n            }\n            \n            // write the new data value \n            console.log('writing ipfs values to ipfs');\n             \n            let value = ipfsHashOfEncryptedData || ipfsHashOfData;\n            let name = routeInfo.lookupPathHash;\n            \n            console.log('name, value:', name, value);\n            \n            // Start building the transaction for manageData update\n            let transaction = new universe.StellarSdk.TransactionBuilder(identityAccount)\n            \n            .addOperation(universe.StellarSdk.Operation.manageData({\n              name, // just use /path ? \n              value // encrypted, if exists \n            }))\n            // .addMemo(StellarSdk.Memo.hash(b32))\n            .build();\n  \n            // Sign the transaction to prove you are actually the person sending it.\n            transaction.sign(routeInfo.pairForIdentity); // targetKeys\n            transaction.sign(pairForWrite); // sourceKeys\n  \n            // send to stellar network\n            let stellarResult = await stellarServer.submitTransaction(transaction)\n            .then(function(result) {\n              console.log('Stellar manageData Success! Results:'); //, result);\n              return result;\n            })\n            .catch(function(error) {\n              console.error('Stellar Something went wrong (failed updating data)!', error);\n              // If the result is unknown (no response body, timeout etc.) we simply resubmit\n              // already built transaction:\n              // server.submitTransaction(transaction);\n              return null;\n            });\n  \n            // console.log('stellarResult', stellarResult);\n  \n            if(!stellarResult){\n              console.error('Failed stellar manageData');\n              throw 'Failed stellar manageData'\n            }\n  \n            console.log('stellarResult succeeded! (manageData)');\n            \n            console.log('stellarResult', stellarResult);\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed saving route', err);\n            \n            this.setState({\n              failedSaving: 'Failed saving route'\n            })\n          \n          }\n          \n          this.setState({isSaving: false});\n          \n        }\n        \n        @autobind\n        async handleSendMessage(){\n          \n          // Get address to send to \n          // - expecting only one type of address (https) \n          \n          let text = this.state.msgValue;\n          if(!text){\n            return false;\n          }\n          \n          this.setState({\n            isSending: true,\n            failedSending: false\n          })\n          \n          // Load message-input node for username \n          let routeInfo = await this.parseRoute(this.state.sendMessageHost);\n          if(!routeInfo){\n            this.setState({\n              isSending: false,\n              failedSending: 'Invalid route'\n            });\n            return false;\n          }\n          \n          let nodeForLookup = await this.loadIdentityRoute(routeInfo.protocol, routeInfo.pairForIdentity.publicKey(), routeInfo.lookupPath);\n          \n          if(!nodeForLookup){\n            // Unable to find valid \n            console.error('Failed to lookup connection info');\n            this.setState({\n              isSending: false,\n              failedSending: 'Failed to find user connection info (1)'\n            })\n            return false;\n          }\n          \n          try {\n            nodeForLookup = universe.cJSON.parse(nodeForLookup);\n          }catch(err){\n            console.error('invalid node returned');\n            this.setState({\n              isSending: false,\n              failedSending: 'Failed to find user connection info (2)'\n            })\n            return false;\n          }\n          \n          console.log('nodeForLookup:', nodeForLookup);\n          \n          let secondUrl;\n          try {\n            secondUrl = nodeForLookup.data.urls['message-drop'];\n          }catch(err){\n            // invalid urls\n            console.error('Invalid URLs for message-drop');\n            this.setState({\n              isSending: false,\n              failedSending: 'Failed to find user connection info (3)'\n            })\n            return false;\n          }\n          \n          // TODO: validate message-drop endpoint (should be signed by user?) \n          \n          let upNode = this.props.state.UsernamePassphraseNode;\n          \n          let messageNode = {\n            type: 'signed_message:Qmtesting',\n            data: {\n              msgId: universe.uuidv4(), // for uniqueness\n              to: routeInfo.fullName, // TODO: encrypt for that username too? using a different pubkey? \n              from: upNode.data.username,\n              content: {\n                type: 'text:Qmtesting',\n                data: {\n                  text\n                }\n              },\n              sig: undefined,\n              // createdAt ? \n            }\n          }\n          \n          // Sign \n          // - order keys, stringify each value\n          var passwordPair = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n          \n          let stringToSign = Object.keys(messageNode.data).sort().map(k=>JSON.stringify(messageNode.data[k])).join('');\n          console.log('stringToSign:',stringToSign);\n          \n          let sig = passwordPair.sign(stringToSign).toString('base64'); \n          \n          console.log('sig:', sig);\n          \n          // add signature to data \n          messageNode.data.sig = sig;\n          \n          let response = await universe.fetch(secondUrl, {\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\", // charset=utf-8\n            },\n            body: JSON.stringify(messageNode)\n          })\n          console.log('Response:', response);\n          \n          let responseJson = await response.json();\n          \n          console.log('responseJson', responseJson);\n          \n          // Success receiving?\n          try {\n            if(responseJson.data != true){\n              throw \"Failed\"\n            }\n          }catch(err){\n            console.error('Failed sending, could not reach endpoint');\n            this.setState({\n              isSending: false,\n              failedSending: 'Sending Failed (could not reach endpoint)'\n            });\n            return false;\n          }\n          \n          // Push to \"sent\" messages (in memory only) \n          \n          let newOutgoing = await universe.newNode(messageNode);\n          \n          this.setState({\n            msgValue: '',\n            isSending: false,\n            failedSending: false\n          })\n          \n          this.fetchOutgoingMessages();\n          \n        }\n        \n        @autobind\n        async fetchOutgoingMessages(){\n          \n          let outgoingMessages = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                type: 'signed_message:Qmtesting',\n              }\n            }\n          });\n          \n          this.setState({\n            outgoingMessages\n          })\n          \n          \n        }\n        \n        @autobind\n        handleViewAccount(){\n          \n          let stellarKey = this.state.stellarKey;\n          \n          let routePath = this.state.routePath;\n          \n          try {\n              \n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routePath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routePath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                throw 'Invalid protocol'\n            }\n            \n            let baseIdentity = parser.host;\n            \n            let pkTargetSeed = universe.jsSHA256.array(baseIdentity);\n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            let href = `https://horizon-testnet.stellar.org/accounts/${pairTarget.publicKey()}`;\n            \n            WINDOW.open(href, '_blank');\n            \n            console.log('href:', href);\n          \n          }catch(err){\n            console.error('Failed finding identity link:', err);\n            \n          }\n        }\n        \n        @autobind\n        createIpfsHashOnSecond(fileValue){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                isCreating: true\n              })\n              \n              // let response = await universe.loadAndRunCapability('TalkToSecond',{\n              //   type: 'default_loadandruncapability_options:Qmf239j',\n              //   data: {\n              //     skipSameAppPlatform: true\n              //   }\n              // },{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'send',\n              //     options: {\n              //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n              //       RequestNode: {\n              //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              //         data: {\n              //           actions: [\n                          \n              //             {\n              //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              //               dataForAction: {\n              //                 type: 'string:...',\n              //                 data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n              //               }\n              //             },\n                      \n              //             { \n              //               matchActionType: 'ipfs_file_add:Qmfmk230fjs',\n              //               dataForAction: {\n              //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n              //                 data: {\n              //                   type: 'file_with_data_and_options:Qmdf23ifsmkmm',\n              //                   data: {\n              //                     options: {\n              //                       pin: true\n              //                     },\n              //                     fileValue\n              //                   }\n              //                 }\n              //               }\n              //             },\n                          \n              //           ]\n                        \n              //         }\n              //       }\n              //     }\n              //   }\n              // });\n              \n              // console.log('Response:', response);\n              \n              // let hash = response.data.actionResponses[1].data.hash;\n              \n              console.log('stellarKey:', this.state.stellarKey);\n              var passwordPair = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n              \n              let sourcePublicKey = passwordPair.publicKey();\n              let sig = passwordPair.sign(fileValue).toString('base64'); //fileValue);\n              \n              console.log('sig:', sig, typeof sig);\n              \n              universe.fetch('/ipfs-pin',{\n                method: 'POST',\n                headers: {\n                    \"Content-Type\": \"application/json\", // charset=utf-8\n                },\n                body: JSON.stringify({\n                  username: this.state.inviteCode,\n                  sourcePublicKey, \n                  sig,\n                  fileAsString: fileValue\n                })\n              })\n              .then(response=>{\n                console.log('Response1:', response);\n                if(response.status == 200){\n                  return response;\n                }\n                // failed!\n                console.error('failed!', respones);\n                // this.setState({\n                //   generatingLumens: false,\n                //   lumensMessage: 'Failed populating seed wallet'\n                // })\n                // throw \"Failed populating seed wallet with Friendbot lumens\"\n                reject()\n              })\n              .then(response=>response.json())\n              .then(async (response)=>{\n                console.log('Response:', response);\n                \n                // Succeeded in creating ownership account for us to reserve the username \n                // - NOT creatinig username on server, just accepting the invite for controller account \n                //   - prevents passphrase from needing to go to the server (just send the pubkey!) \n                \n                if(response.data.success != true){\n                  console.error('Failed:', response.data);\n                  WINDOW.alert('Failed pinning IPFS data, please try again or contact support');\n                  reject();\n                  return false;\n                }\n                \n                console.log('success pinning!');\n                \n                let hash = response.data.hash || 'MISSING HASH';\n                \n                console.log('hash:', hash);\n                \n                resolve(hash);\n                \n                \n              })\n              .catch((err)=>{\n                console.error(err);\n                reject();\n              })\n                \n              \n              // // Pin! \n              // resolve(hash);\n              // // {\n              // //   type: 'ipfs_hash:Qmdflj',\n              // //   data: hash\n              // // });\n              \n            } catch(err){\n              console.error('Failed TalkToSecond request', err);\n              reject();\n            }\n          \n            this.setState({\n              isCreating: false\n            })\n            \n            \n            return;\n            \n          });\n          \n        }\n        \n        @autobind\n        handlePrettify(){\n          \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              dataValue: JSON.stringify(nodeData, null, 2)\n            })\n            \n          }catch(err){\n          }\n          \n          \n        }\n        \n        @autobind\n        handleUpdateDefaultInput(name){\n          \n          let dataValue = '';\n          \n          switch(name){\n            case 'meta_redirect':\n              dataValue = '' + \n`<html>\n  <head>\n    <meta http-equiv=\"refresh\" content=\"0;url=http://example.com\" />\n  </head>\n</html>`\n              break;\n              \n            default:\n              break;\n          }\n          \n          this.setState({\n            dataValue\n          });\n          \n          return false;\n          \n        }\n        \n        @autobind\n        renderRoutePartial(){\n          \n          return (\n            \n            <div>\n              {/* Route Input/Buttons */}  \n              <div className=\"\">\n              \n                {/* Desktop version */}  \n                <div className=\"is-hidden-touch\">\n                  <div className=\"field has-addons\">\n                    <div className=\"control has-icons-left\">\n                      <input className=\"input\" value={this.state.routeHost} onChange={e=>this.setState({routeHost:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" />\n                        <span className=\"icon is-small is-left\">\n                          <i className=\"fas fa-user-circle\"></i>\n                        </span>\n                    </div>\n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.routeText} onChange={e=>this.setState({routeText:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" onKeyDown={this.handleSearchKeyDown} />\n                    </div>\n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.isSearching ? 'is-loading':'')} onClick={this.handleSearch}>Load Data For Route</button>\n                    </div>\n                    <div className=\"control\">\n                      <button className={\"button is-success \" + (this.state.isSaving ? 'is-loading':'')} \n                      onClick={this.handleAddRouteData}\n                      disabled={this.state.routeHost != this.state.defaultRouteHost}\n                      >Save Data</button>\n                    </div>\n                    \n                    {/* can be claimed? \n                    <div className=\"control\">\n                      <button className={\"button is-default \" + (this.state.isClaiming ? 'is-loading':'')} \n                      onClick={this.handleClaimUsername}\n                      disabled={!this.state.usernameClaimable}>Claim Username</button>\n                    </div>\n                    <div className=\"control\">\n                      <button className={\"button is-default \" + (this.state.isFunding ? 'is-loading':'')} onClick={this.handleFundAccount}>Add Funds</button>\n                    </div>\n                    \n                    \n                    <div className=\"control\">\n                      <button className={\"button is-default \"} onClick={this.handleViewAccount}>View Account</button>\n                    </div>\n                    \n                    <div className=\"control\">\n                      <button className={\"button is-default \"}>Change Private Key (SBKO...)</button>\n                    </div>\n                    */}\n                    \n                  </div>\n                </div>\n                \n                  \n                {/* Mobile version*/}\n                <div className=\"is-hidden-desktop\">\n                  \n                  <div className=\"field has-addons\">\n                    <div className=\"control has-icons-left is-expanded\">\n                      <input className=\"input\" value={this.state.routeHost} onChange={e=>this.setState({routeHost:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" />\n                      <span className=\"icon is-small is-left\">\n                        <i className=\"fas fa-user-circle\"></i>\n                      </span>\n                    </div>\n                  </div>\n                  <div className=\"field has-addons\">\n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.routeText} onChange={e=>this.setState({routeText:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" onKeyDown={this.handleSearchKeyDown} autocapitalize=\"off\" />\n                    </div>\n                  </div>\n                  <div className=\"field has-addons\">\n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.isSearching ? 'is-loading':'')} onClick={this.handleSearch}>Load Data For Route</button>\n                    </div>\n                    <div className=\"control\">\n                      <button className={\"button is-success \" + (this.state.isSaving ? 'is-loading':'')} \n                      onClick={this.handleAddRouteData}\n                      disabled={!this.state.usernameOwnedByMe}\n                      >Save Data</button>\n                    </div>\n                  </div>\n                \n                </div>\n                \n                \n                <div>\n                  {\n                    !this.state.failedAdd ? '':\n                    <span className='has-text-danger'>\n                      Failed adding\n                    </span>\n                  }\n                  {\n                    !this.state.failedSearch ? '':\n                    <span className='has-text-danger'>\n                      Failed loading route data\n                    </span>\n                  }\n                  {\n                    !this.state.failedClaim ? '':\n                    <span className='has-text-danger'>\n                      Failed claiming identity\n                    </span>\n                  }\n                  {\n                    !this.state.failedFunding ? '':\n                    <span className='has-text-danger'>\n                      Failed funding\n                    </span>\n                  }\n                  &nbsp;\n                </div>\n                \n              </div>\n              \n              <br />\n              \n              <div>\n                \n                <textarea \n                  className='textarea' \n                  onChange={e=>this.setState({dataValue: e.target.value})} \n                  onKeyDown={this.handleTextareaKeydown}\n                  value={this.state.dataValue} \n                  rows=\"10\" \n                />\n                \n                <br />\n              \n                <div className=\"control\">\n                  <button \n                    className={\"button is-default \"} \n                    onClick={this.handlePrettify}\n                    disabled={!this.state.canParse}\n                  >Prettify JSON</button>\n                </div>\n                \n                <br />\n                \n                <p>\n                  Defaults: \n                </p>\n                <a onClick={e=>this.handleUpdateDefaultInput('meta_redirect')}>\n                  Meta Redirect\n                </a>\n              </div>\n              \n              <br />\n              \n              <div className=\"\">\n                <span>\n                  Anyone can view the route's data by visiting: \n                  <br />\n                  <a href={`https://viewsecondroute.com/raw/${this.state.routeFullPath}`}>\n                    https://viewsecondroute.com/raw/{this.state.routeFullPath}\n                  </a> (server-side) \n                  <br />\n                  or \n                  <br />\n                  <a href={`https://viewsecondroute.com/view/${this.state.routeFullPath}`}>\n                    https://viewsecondroute.com/view/{this.state.routeFullPath}\n                  </a> (client-side) \n                </span>\n              </div>\n              \n            </div>\n            \n          )\n          \n        }\n        \n        @autobind\n        renderSendMessagePartial(){\n          \n          return (\n            \n            <div>\n            \n              <div className=\"\">\n              \n                {/* Desktop version */}  \n                <div className=\"is-hidden-touch\">\n                  <div className=\"field has-addons\">\n                    <div className=\"control has-icons-left is-expanded\">\n                      <input className=\"input\" value={this.state.sendMessageHost} onChange={e=>this.setState({sendMessageHost:e.target.value})} placeholder=\"\" />\n                      <span className=\"icon is-small is-left\">\n                        <i className=\"fas fa-user-circle\"></i>\n                      </span>\n                    </div>\n                    <div className=\"control\">\n                      <button \n                        className={\"button is-default \" + (this.state.isSending ? 'is-loading':'')} \n                        onClick={this.handleSendMessage}\n                        disabled={!this.state.msgValue.length}\n                      >Send Message</button>\n                    </div>\n                    \n                  </div>\n                </div>\n                \n                  \n                {/* Mobile version*/}\n                <div className=\"is-hidden-desktop\">\n                  \n                  <div className=\"field has-addons\">\n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.sendMessageHost} onChange={e=>this.setState({sendMessageHost:e.target.value})} placeholder=\"\" />\n                    </div>\n                  </div>\n                  <div className=\"field has-addons\">\n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.isSending ? 'is-loading':'')} onClick={this.handleSendMessage}>Send Message</button>\n                    </div>\n                  </div>\n                \n                </div>\n                \n                \n                <div>\n                  {\n                    !this.state.failedSending ? '':\n                    <span className='has-text-danger'>\n                      {this.state.failedSending}\n                    </span>\n                  }\n                  &nbsp;\n                </div>\n                \n              </div>\n              \n              <br />\n              \n              <div>\n                \n                <textarea \n                  className='textarea' \n                  onChange={e=>this.setState({msgValue: e.target.value})} \n                  onKeyDown={this.handleTextareaKeydown}\n                  value={this.state.msgValue} \n                  rows=\"10\" \n                />\n                \n              </div>\n              \n              <br />\n              \n              <div>\n                \n                <h3 className=\"title is-6\">\n                  Outgoing Messages (in-memory) \n                </h3>\n                \n                {\n                  this.state.outgoingMessages.length ? \n                    <div>\n                      {\n                        this.state.outgoingMessages.sort((a,b)=>{return a.createdAt < b.createdAt}).map(msg=>{\n                          return (    \n                            <div key={msg._id} style={{borderTop:'1px solid #cecece', padding: '4px'}}>\n                              <small>\n                                To: {msg.data.to}\n                              </small>\n                              <br />\n                              {msg.data.content.data.text}\n                              <br />\n                              <small>\n                                {universe.moment(msg.createdAt, 'x').fromNow()}\n                              </small>\n                            </div>\n                          )\n                        })\n                      }\n                    </div>\n                  :\n                    <div>\n                      No sent messages\n                    </div>\n                }\n                \n              </div>\n              \n            </div>\n            \n          )\n          \n        }\n        \n        @autobind\n        renderReceiveMessagesPartial(){\n          \n          let PartialReceiveMessagesComponent = this.state.PartialReceiveMessagesComponent || WINDOW.ErrorComponent('PartialReceiveMessagesComponent');\n          \n          return (\n            \n            <div>\n              <PartialReceiveMessagesComponent\n                onSetupReceive={this.emitBrowserProxySetup}\n              />\n            </div>\n            \n          )\n          \n        }\n        \n        @autobind\n        renderTransferPartial(){\n          \n          return (\n            \n            <div>\n              {/* Route Input/Buttons */}  \n              <div className=\"\">\n              \n                {/* Desktop version */}  \n                <div className=\"is-hidden-touch\">\n                \n                  <div className=\"field is-horizontal\">\n                    <div className=\"field-label is-normal\">\n                      <label className=\"label\">From</label>\n                    </div>\n                    <div className=\"field-body\">\n        \n                      <div className=\"field has-addons\">\n                        <div className=\"control is-expanded\">\n                          <input className=\"input\" value={this.state.fromRouteHost} onChange={e=>this.setState({fromRouteHost:e.target.value})} placeholder=\"password/secret\" />\n                        </div>\n                        <div className=\"control\">\n                          <button className={\"button is-default \" + (this.state.gettingBalance[0] ? 'is-loading':'')} \n                          onClick={e=>this.getBalance(0)}\n                          > Get Balance {this.state.balanceOf[0] ? `(${this.state.balanceOf[0]})`:''}</button>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                  \n                  <div className=\"field is-horizontal\">\n                    <div className=\"field-label is-normal\">\n                      <label className=\"label\">To</label>\n                    </div>\n                    <div className=\"field-body\">\n        \n                      <div className=\"field has-addons\">\n                        <div className=\"control is-expanded\">\n                          <input className=\"input\" value={this.state.toRouteHost} onChange={e=>this.setState({toRouteHost:e.target.value})} placeholder=\"username\" />\n                        </div>\n                        <div className=\"control\">\n                          <button className={\"button is-default \" + (this.state.gettingBalance[1] ? 'is-loading':'')} \n                          onClick={e=>this.getBalance(1)}\n                          > Get Balance {this.state.balanceOf[1] ? `(${this.state.balanceOf[1]})`:''}</button>\n                        </div>\n                        \n                      </div>\n                    </div>\n                  </div>\n                  \n                  <div className=\"field is-horizontal\">\n                    <div className=\"field-label is-normal\">\n                      <label className=\"label\">Amount</label>\n                    </div>\n                    <div className=\"field-body\">\n        \n                      <div className=\"field\">\n                        <div className=\"control\">\n                          <input className=\"input\" value={this.state.transferAmount} onChange={e=>this.setState({transferAmount:e.target.value})} placeholder=\"Lumens (XLM)\" />\n                        </div>\n                        <p className=\"help\">\n                          Use a small increment first to verify the transaction succeeds \n                        </p>\n                      </div>\n                    </div>\n                  </div>\n                  \n                  \n                  <div className=\"field is-horizontal\">\n                    <div className=\"field-label is-normal\">\n                    </div>\n                    <div className=\"field-body\">\n        \n                      <div className=\"field\">\n                      \n                        <div className=\"control\">\n                          <button \n                            className={\"button is-primary \" + (this.state.isTransferring ? 'is-loading':'')} \n                            onClick={this.handleTransfer}\n                          >Add Route Funds</button>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                  \n                  <div>\n                    {\n                      !this.state.failedTransfer ? '':\n                      <span className='has-text-danger'>\n                        {this.state.failedTransfer}\n                      </span>\n                    }\n                    &nbsp;\n                  </div>\n                  \n                  \n                    \n                </div>\n                \n              </div>\n              \n              <br />\n              \n              \n              <br />\n              \n              <div className=\"\">\n              </div>\n              \n            </div>\n            \n          )\n          \n        }\n        \n        render(){\n          \n          var hostUrl = WINDOW.location.protocol + \"//\" + WINDOW.location.host;\n          \n          return (\n        \n            <div className=\"section\">\n              <div className=\"container\">\n                <div className=\"columns\">\n                \n                  <div className=\"column is-6 is-offset-3\">\n                    \n                    <div className=\"columns\">\n                      <div className=\"column is-9\">\n                      \n                      \n                        <div className=\"title is-4\">\n                          <span style={{opacity:'0.6',color:'#444'}}>\n                            {\n                              this.props.state.UsernamePassphraseNode.data.network == 'public' ? \n                              ''\n                              :<span><span className=\"tag is-warning\">test</span>&nbsp;</span>\n                            }\n                          </span>\n                          {this.props.state.UsernamePassphraseNode.data.username}\n                        </div>\n                        <div className=\"subtitle is-6\">\n                          <strong>Passphrase: </strong>\n                          <span onClick={e=>{WINDOW.prompt('',this.props.state.UsernamePassphraseNode.data.passphrase)}}>{this.props.state.UsernamePassphraseNode.data.passphrase.substring(0,10)}...</span>\n                        </div>\n                        {/*\n                        <div>\n                          <span>Storage: 0.5GB</span>\n                        </div>\n                        <div>\n                          <span>Routes: {this.state.routesRemaining}</span>\n                        </div>\n                        */}\n                      \n                      </div>\n                      \n                      {/*<div className=\"column is-3\">\n                        <button className={\"button is-info \"} onClick={this.setupOrbitDb}>Setup Peer</button>\n                      </div>\n                      */}\n                      <div className=\"column is-3 has-text-right\">\n                        \n                        {/* status of ipfs */}\n                        <div \n                          style={{display:'inline-block',width:'50px',height:'4px',backgroundColor:this.state.connectedColor}}\n                          onClick={this.checkIpfsConnected}\n                        >\n                          &nbsp;\n                        </div>\n                        \n                        <br />\n                          \n                        <div className=\"dropdown is-hoverable is-right has-text-left\">\n                          <div className=\"dropdown-trigger\">\n                            <button className=\"button is-default\" aria-haspopup=\"true\" aria-controls=\"dropdown-menu3\">\n                              <span className=\"icon is-small\">\n                                <i className=\"fas fa-angle-down\" aria-hidden=\"true\"></i>\n                              </span>\n                            </button>\n                          </div>\n                          <div className=\"dropdown-menu\" id=\"dropdown-menu3\" role=\"menu\">\n                            <div className=\"dropdown-content\">\n                              <a className=\"dropdown-item\" onClick={()=>{WINDOW.UpdateApp()}}>\n                                Update\n                              </a>\n                              <a className=\"dropdown-item\" onClick={e=>this.setState({tabsMainSelected:'transfer'})}>\n                                Fund Routes\n                              </a>\n                              <div className=\"dropdown-divider\"></div>\n                              <a className=\"dropdown-item is-warning\" onClick={this.logout}>\n                                Logout\n                              </a>\n                            </div>\n                          </div>\n                        </div>\n                        \n                      </div>\n                      \n                        \n                      \n                    </div>\n                    \n                          \n                    <div className=\"tabs\">\n                      <ul>\n                        {\n                          this.state.tabsMainPossible.map(tab=>(\n                            <li key={tab[0]}\n                              onClick={e=>this.setState({tabsMainSelected:tab[0]})}\n                              className={(this.state.tabsMainSelected == tab[0]) ? 'is-active':''}\n                              ><a>{tab[1]}</a></li>\n                          ))\n                        }\n                      </ul>\n                    </div>\n                    \n                    {\n                      this.state.tabsMainSelected != 'route' ? '':\n                      this.renderRoutePartial()\n                    }\n                    \n                    {\n                      this.state.tabsMainSelected != 'send_message' ? '':\n                      this.renderSendMessagePartial()\n                    }\n                    \n                    {\n                      this.state.tabsMainSelected != 'receive_messages' ? '':\n                      this.renderReceiveMessagesPartial()\n                    }\n                    \n                    {\n                      this.state.tabsMainSelected != 'transfer' ? '':\n                      this.renderTransferPartial()\n                    }\n                    \n                    \n                    \n                  </div>\n                  \n                </div>\n                \n              </div>\n              \n            </div>\n            \n            \n          )\n        }\n      }\n      \n      if(universe.sharedComponents && universe.sharedComponents.withEditableNodeInfo){\n        mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n          localNode: SELF,\n          localNodeIsRemote: true\n        });\n      }\n       \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  }
}