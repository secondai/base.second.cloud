{
  "name": "base.second.cloud.data.second.default.routes.api_get_for_pattern.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: --', SELF.name);\n      \n      // This is just temporary! \n      \n      let bodyNode = INPUT.data.req.body;\n      \n      console.log('bodyNode:', bodyNode);\n      \n  \t\t// if(!bodyNode.paths){\n  \t\t//   console.error('Missing array of paths');\n    //     await universe.httpResponse('send', false);\n  \t\t//   return false;\n  \t\t// }\n  \t\t\n  \t\t// array of paths is expected\n  \t\t// - i.e. [\"data.second.default.routes.*\"]\n  \t\t\n  \t\t// let name = bodyNode.name.replace(/\\*\\*/g,'$').replace(/\\*/g,'\\\\w+');\n  \t\t\n  \t\t// const Op = universe.sharedServices.db.Sequelize.Op;\n\t\t  // let nodes = await universe.sharedServices.db.Node.findAll({\n\t\t  //   where: {\n\t\t  //     name: {\n\t\t  //       [Op.regexp]: name\n\t\t  //     }\n\t\t  //   },\n\t\t  //   raw: true\n\t\t  // });\n\t\t  const Op = universe.sharedServices.db.Sequelize.Op;\n\t\t  \n\t\t  // let topLevelNodes = await universe.sharedServices.db.Node.findAll({\n\t\t  //   where: {\n\t\t\t //   \tname: {\n\t\t\t //   \t\t[Op.regexp]: '^(app)\\\\.(\\\\w+)\\\\.(\\\\w+)$' // limit to top-level! \n\t\t\t //   \t}\n\t\t\t //   },\n\t\t  //   raw: true\n\t\t  // });\n\t\t  // // console.log('TOP-LEVEL2222:', topLevelNodes.length);\n\t\t  // // return false;\n\t\t  // console.log('TOP LEVEL3:', topLevelNodes.length);\n\t\t  \n\t\t  // await universe.httpResponse('send', topLevelNodes);\n\t\t  // return;\n\t\t  \n\t\t  let pattern;\n\t\t  if(bodyNode.paths){\n\t\t    pattern = bodyNode.paths[0];\n\t\t    if(bodyNode.paths.length > 1){\n\t\t      console.error('Multiple paths for pattern!! Error (should only expect 1 incoming)');\n\t\t    }\n\t\t  }\n\t\t  if(bodyNode.pattern){\n\t\t    pattern = bodyNode.pattern;\n\t\t  }\n\t\t  \n      let nodes = await universe.getNodesForPathPattern(pattern,{\n        excludeData: bodyNode.excludeData || false\n      });\n      \n      // let returnNodes = [];\n      let returnNodes = nodes;\n      \n      // // exclude data? \n      // if(!bodyNode.excludeData){\n      //   returnNodes = nodes;\n      // } else {\n          \n      //   // rebuild children w/o data \n      //   function noData(node){\n          \n      //     // active: true\n      //     // createdAt: 1524632541511\n      //     // name: \"platform_nodes\"\n      //     // nodeId: \"5ae00bdd6b2f710021b72238\"\n      //     // nodes: (86)\n      //     // parent: Node,\n      //     // placeholder: false\n      //     // type: \"platform_nodes:Qmtlksjflsdjfljf\"\n      //     // updatedAt: null\n      //     // _id: \"5ae00bdd6b2f710021b72239\"\n      //     // _path: \"app_store_cloud.platform_nodes\"\n      //     // _root: Node,\n      //     // _rootChain: (2) []\n          \n      //     let newNode = universe.lodash.pick(node, [\n      //       'type',\n      //       'name',\n      //       'placeholder',\n      //       'createdAt',\n      //       'updatedAt'\n      //     ])\n      //     delete newNode.data;\n      //     newNode.nodes = [];\n      //     if(node.nodes){\n      //       node.nodes.forEach(tmpNode2=>{\n      //         newNode.nodes.push(noData(tmpNode2));\n      //       })\n      //     }\n      //     return newNode;\n      //   }\n        \n      //   for(let tmpNode of nodes){\n      //     returnNodes.push(noData(tmpNode));\n      //   }\n        \n      // }\n      \n      \n      let response = universe.cJSON.stringify(returnNodes)\n\t\t\t\n      await universe.httpResponse('send', response);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-27T08:23:11.084Z",
  "updatedAt": "2019-04-07T06:39:14.306Z",
  "nodes": []
}