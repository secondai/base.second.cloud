{
  "name": "base.second.cloud.data.second.default.routes.api_remove.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /api/remove (for a path) --');\n      \n      const path = universe.require('path');\n      const fs = universe.require('fs-extra');\n      const globby = universe.require('globby');\n      const micromatch = universe.require('micromatch');\n      \n      let bodyNode = INPUT.data.req.body;\n      \n  \t\t// expecting a valid name \n  \t\t\n  \t\tif(!bodyNode.name){\n  \t\t  console.error('Missing name in body for node');\n        await universe.httpResponse('send', false);\n  \t\t  return false;\n  \t\t}\n  \t\t\n      let opts = bodyNode.opts || {};\n        \n      console.log('removeNodeAtPath', bodyNode.name);\n      let result = await universe.removeNodeAtPath(bodyNode.name, opts);\n      \n      // remove children \n      \n      // copies nodes AND files \n      // - optionally files are copied (NOT by default) \n  \t\t\n  \t\tlet VOLUME = universe.env.ATTACHED_VOLUME_ROOT;\n    \n      let removeFiles = true;\n      // files \n      if(removeFiles){\n        // console.log('directory removing');\n        try {\n          let foldersToRemove = await globby([bodyNode.name, bodyNode.name + '*'],{\n            expandDirectories: true,\n            onlyDirectories: true,\n            cwd: VOLUME,\n          })\n          console.log('foldersToRemove:', foldersToRemove);\n          \n          for(let folderName of foldersToRemove){\n            try {\n              await fs.remove(path.join(VOLUME, folderName));\n            }catch(err){\n              console.error(err);\n            }\n          }\n          \n          // let exists = await fs.exists(path.join(VOLUME, node.name)); // old path has files? \n          // if(exists){\n          //   console.log('exists, emptying dir');\n          //   await fs.emptyDir(path.join(VOLUME, newPath)); // empty new directory\n          //   console.log('copying', path.join(VOLUME, node.name), path.join(VOLUME, newPath));\n          //   await fs.copy( path.join(VOLUME, node.name), path.join(VOLUME, newPath), {\n          //     filter: fileFilterFunc\n          //   } );\n          //   written.push(newPath + '/');\n          // } else {\n          //   // only clear directory if necessary, otherwise don't even create \n          //   console.log('no files, checking directory');\n          //   let existsNew = await fs.exists(path.join(VOLUME, newPath)); // old path has files? \n          //   if(existsNew){\n          //     // clear \n          //     console.log('clearing new directory');\n          //     await fs.emptyDir(path.join(VOLUME, newPath)); // empty new directory\n          //   }\n          // }\n        }catch(err){\n          console.error('fs error:', err);\n        }\n      }\n    \n      console.log('Result of removeNodeAtPath'); //, result);\n      \n      let secondResponseNode = {\n        type: 'types.second.default.response',\n        data: {\n          result\n        }\n      }\n      \n      await universe.httpResponse('send', secondResponseNode);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-05T22:38:10.754Z",
  "updatedAt": "2019-03-17T21:50:37.474Z",
  "nodes": []
}