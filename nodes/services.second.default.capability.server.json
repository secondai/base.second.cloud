{
  "type": "types.second.default.service.js",
  "name": "services.second.default.capability.server",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // TODO: ensure not already running? \n      // - universe.sharedServices? \n      \n      // Setup the Express HTTP Server for handling input \n      console.log('Setting up Express Server (in vm)');\n      \n      let doneCanWipe;\n      universe.wipeFunc = new Promise(resolve=>{\n        doneCanWipe = resolve;\n      });\n      \n      let express = universe.require('express');\n      let path = universe.require('path');\n      let logger = universe.require('morgan');\n      let bodyParser = universe.require('body-parser');\n      \n      var helmet = universe.require('helmet')\n      var cors = universe.require('cors');\n      var cookieParser = universe.require('cookie-parser')\n      var compression = universe.require('compression')\n      \n      const app = express();\n      universe.sharedServices.expressApp = app;\n      // global.console = utilLogger;\n      // utilLogger.debug(\"Overriding 'Express' logger\");\n      // app.use(utilLogger.middleware);\n      app.use(universe.require('morgan')('combined', { \"stream\": universe.sharedServices.loggerStream }));\n      \n      app.use(cors({\n      \torigin: '*',\n      \tcredentials: true\n      }));\n      app.use(cookieParser())\n      \n      // app.use(helmet({\n      // }))\n      \n      app.use(compression())\n      \n      // // View engine setup\n      // // - no views \n      // app.set('views', path.join(__dirname, '../views'));\n      // app.set('view engine', 'pug');\n      \n      app.disable('x-powered-by');\n      \n      // app.use(logger('dev', {\n      //   skip: () => app.get('env') === 'test'\n      // }));\n      app.use(bodyParser({limit: '10mb'}));\n      app.use(bodyParser.json());\n      app.use(bodyParser.urlencoded({ extended: false }));\n      \n      // TODO: handle static files (necessary?) \n      // app.use(express.static(path.join(__dirname, '../public')));\n      \n      console.log('RedisClient start');\n      universe.sharedServices.redis = universe.require(\"redis\");\n    \n      let redisClient = universe.sharedServices.redis.createClient(6379, 'cachedb');\n      universe.sharedServices.redisClient = redisClient;\n      redisClient.on(\"error\", function (err) {\n        console.error(\"Redis Error \" + err);\n      });\n      redisClient.monitor(function (err, res) {\n        console.log(\"Entering monitoring mode.\");\n      });\n      redisClient.on(\"monitor\", function (time, args, raw_reply) {\n        console.log('redisMonitor:', time + \": \" + args); // 1458910076.446514:['set', 'foo', 'bar']\n      });\n      redisClient.set('foo', 'bar');\n\n      console.log('RedisClient setup end');\n      \n      \n      // Session (redis)\n      let sessionStore;\n      const session = universe.require('express-session');\n      // if(universe.sharedServices.redisClient){\n      if(universe.sharedServices.redisClient){\n        console.log('Redis Session Setup');\n        const RedisStore = universe.require('connect-redis')(session);\n        const redisOptions = {\n        \tclient: redisClient,\n        }\n        sessionStore = new RedisStore(redisOptions);\n        console.log('Redis Session Setup Complete');\n      }\n      \n      app.use(session({\n        store: sessionStore,\n        secret: 'sdjkfhsdjkhf92312',\n        resave: false,\n        saveUninitialized: true,\n        cookie: {\n        \tdomain: false, //'acme.etteserver.test',\n        \tsameSite: false\n        }\n      }));\n      \n      // // proxied routes \n      // // - s3-only for now \n      // try {\n      //   const S3Proxy = universe.require('s3proxy');\n        \n      //   const proxy = new S3Proxy({ \n      //     bucket: 'seconddev3-public',\n      //     region: 'us-west-1',\n      //     // accessKeyId: universe.env.AWS_ACCESS_KEY_ID,\n      //     // secretAccessKey: universe.env.AWS_SECRET_ACCESS_KEY\n      //   });\n      //   proxy.init();\n        \n      //   app.route('/health')\n      //     .get((req, res) => {\n      //       proxy.healthCheckStream(res).pipe(res);\n      //     });\n        \n      //   // Make sure to add an error handler (as shown below), otherwise your server will crash if the stream\n      //   // encounters an error (which occurs, for instance, when the requested object doesn't\n      //   // exist).\n      //   app.route('/static/*')\n      //     .get((req, res) => {\n      //       let rewrittenUrl = req.url.substring('/static/*'.length - 2);\n      //       console.log('/static check', rewrittenUrl);\n      //       proxy.get({url: rewrittenUrl}, res)\n      //         .on('error', (err) => {\n      //           console.error('s3 proxy error:', err);\n      //           res.end(); // headers already sent from s3, so no \"\"next()\"\n      //         })\n      //         .pipe(res);\n      //     });\n        \n      //   console.log('Express S3 Proxy is setup');\n        \n      // }catch(err){\n      //   console.error('s3 proxy setup failure', err);\n      // }\n      \n      \n      // normal routes\n      app.use(bodyParser.json(), async (req, res, next)=>{\n        \n        // // socket io handling is special?\n        // // - cannot force it \"ahead\" of other routes \n        // if(req.path == '/socket.io/socket.io.js'){\n        //   console.log('socketio path');\n        //   return next();\n        // }\n      \t\n      \t// wait for the result from the AI request \n      \t// - passing in the \"request arrived like X\" information that will give us a valid response to return \n      \t// - response might be a res.send({...everything..}) or simply res.send({resultId:'123'}) w/ a follow-up later \n      \t\n      // \tconsole.log('Got HTTP request in app.use');\n      \t\n      \t// handle using execService \n      \t\n  \t\t\tlet requestId = universe.uuidv4();\n  \t\t\tuniverse.requestsCache[requestId] = {\n  \t\t\t\tkeyvalue: {},\n  \t\t\t\tstack: [],\n  \t\t\t\treq,\n  \t\t\t\tres\n  \t\t\t};\n  \t\t\t\n  \t\t\tlet response = await universe.execService('services.second.default.input.from_http', {\n  \t\t\t  actionPath: 'builtin.input',\n  \t\t\t  inputNode: {\n    \t\t\t\ttype: 'types.second.default.request.http_express_obj',\n    \t\t\t\tdata: {\n    \t\t\t\t\treq, // convert using circular-json when stringifying \n    \t\t\t\t\tres\n    \t\t\t\t},\n  \t\t\t  },\n  \t\t\t  isOwner: true, // we'll end up using the authNode that is supplied \n  \t\t\t\trequestId\n  \t\t\t});\n      \n        // console.log('http response from inside vm');\n        console.log('-- Finished universe.execService(services.second.default.input.from_http) --');\n        \n      });\n\n      \n      // Catch 404 and forward to error handler\n      app.use((req, res, next) => {\n        const err = new Error('Not Found');\n        err.status = 404;\n        next(err);\n      });\n      \n      // Error handler\n      app.use((err, req, res, next) => {\n        res\n          .status(err.status || 500)\n          .send('Not found');\n      });\n      \n      console.log('Express App Server warming up...');\n      \n      const http = universe.require('http');\n      const server = http.createServer(app);\n      \n      let { PORT = 8080 } = universe.env;\n      \n      server.listen(PORT, () => {\n        console.info('Second AI Express Server is now running (from inside vm)');\n      });\n      \n      universe.sharedServices.httpServer = server;\n      \n      return resolve({\n        type: 'boolean:Qmsdflkj',\n        data: true\n      });\n        \n    }catch(err){\n      console.error('err setting up express server:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}