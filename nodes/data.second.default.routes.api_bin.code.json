{
  "name": "base.second.cloud.data.second.default.routes.api_bin.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--API binary tools (for a PATH): --', SELF.name);\n      \n      const util = universe.require('util');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n      \n      \n      // This is just temporary! \n      let {\n        req,\n        res\n      } = INPUT.data;\n      \n      let pathToRegExp = universe.require('path-to-regexp');\n      \n      function matchRoute(route){\n        let keys = [];\n        let re = pathToRegExp(route, keys)\n        let matches = re.exec(req.originalUrl)\n        if(!matches){\n          return null;\n        }\n        let params = {};\n        keys.forEach((key, i)=>{\n          params[key.name] = matches[i + 1];\n        });\n        return {\n          route,\n          params\n        };\n      }\n      \n      \n      let routePath;\n      let routeMatch;\n      \n      var buildpath,\n        nodePath,\n        selfOrOther,\n        allowedBuildTypes = [\n          'types.second.default.app',\n          'types.second.default.code.js',\n          'types.second.default.route'\n        ],\n        node;\n        \n        \n      // INSTALL  \n      // - fetch .zip or repo\n      // - clear local directory \n      routePath = '/api/bin/install/:nodePath/:selfOrOther';\n      routeMatch = matchRoute(routePath);\n      if(routeMatch){\n        console.log('MATCH INSTALL:', routeMatch.params.nodePath, routeMatch.params.selfOrOther);\n        var {nodePath, selfOrOther} = routeMatch.params;\n  \t\t\tlet installResultNode = await universe.execService('services.second.default.bin.install', {\n  \t\t\t  actionPath: 'builtin-input',\n  \t\t\t  inputNode: {\n  \t\t\t    type: 'types.second.default.bin.install.input',\n  \t\t\t    data: {\n  \t\t\t      nodePath,\n  \t\t\t      target: selfOrOther,\n  \t\t\t      opts: {}\n  \t\t\t    }\n  \t\t\t  },\n  \t\t\t\tisOwner: true\n  \t\t\t});\n  \t\t\t\n  \t\t\tres.send(installResultNode);\n  \t\t\treturn;\n        \n      }\n      \n      \n      \n      // BUILD \n      // - docker build \n      //   - dockerfile from local \n      // - docker run \n      //   - \n      routePath = '/api/bin/build/:nodePath/:selfOrOther';\n      routeMatch = matchRoute(routePath);\n      if(routeMatch){\n        console.log('MATCH BUILD:', routeMatch.params.nodePath, routeMatch.params.selfOrOther);\n        var {nodePath, selfOrOther} = routeMatch.params;\n        \n  \t\t\tlet buildResultNode = await universe.execService('services.second.default.bin.build', {\n  \t\t\t  actionPath: 'builtin-input',\n  \t\t\t  inputNode: {\n  \t\t\t    type: 'types.second.default.bin.build.input',\n  \t\t\t    data: {\n  \t\t\t      nodePath,\n  \t\t\t      target: selfOrOther,\n  \t\t\t      opts: {\n  \t\t\t        containerOrCode: req.body ? req.body.containerOrCode:null \n  \t\t\t      }\n  \t\t\t    }\n  \t\t\t  },\n  \t\t\t\tisOwner: true\n  \t\t\t});\n  \t\t\t\n  \t\t\tres.send(buildResultNode);\n  \t\t\treturn;\n      }\n      \n      // RUN \n      // - whatever command that already exists in target[key].commands[...]\n      routePath = '/api/bin/run/:nodePath/:selfOrOther'; // self, frontend\n      routeMatch = matchRoute(routePath);\n      if(routeMatch){\n        console.log('MATCH BUILD:', routeMatch.params);\n        var {nodePath, selfOrOther} = routeMatch.params;\n        \n  \t\t\tlet runResultNode = await universe.execService('services.second.default.bin.run', {\n  \t\t\t  actionPath: 'builtin-input',\n  \t\t\t  inputNode: {\n  \t\t\t    type: 'types.second.default.bin.run.input',\n  \t\t\t    data: {\n  \t\t\t      nodePath,\n  \t\t\t      target: selfOrOther,\n  \t\t\t      opts: {\n  \t\t\t        command: req.body ? req.body.command:null \n  \t\t\t      }\n  \t\t\t    }\n  \t\t\t  },\n  \t\t\t\tisOwner: true\n  \t\t\t});\n  \t\t\t\n  \t\t\tres.send(runResultNode);\n  \t\t\treturn;\n      }\n      \n      \n      // CLEAR \n      // - for handling failing builds, etc.\n      routePath = '/api/bin/clear/:nodePath/:selfOrOther';\n      routeMatch = matchRoute(routePath);\n      if(routeMatch){\n        console.log('MATCH CLEAR:', routeMatch.params.nodePath, routeMatch.params.selfOrOther);\n        var {nodePath, selfOrOther} = routeMatch.params;\n        \n  \t\t\tlet clearResultNode = await universe.execService('services.second.default.bin.clear', {\n  \t\t\t  actionPath: 'builtin-input',\n  \t\t\t  inputNode: {\n  \t\t\t    type: 'types.second.default.bin.clear.input',\n  \t\t\t    data: {\n  \t\t\t      nodePath,\n  \t\t\t      target: selfOrOther,\n  \t\t\t      opts: {\n  \t\t\t        dryRun: false\n  \t\t\t      }\n  \t\t\t    }\n  \t\t\t  },\n  \t\t\t\tisOwner: true\n  \t\t\t});\n  \t\t\t\n  \t\t\tres.send(clearResultNode);\n  \t\t\treturn;\n      }\n      \n      \n      // Editing \n      routePath = '/api/bin/edit/:editpath';\n      routeMatch = matchRoute(routePath);\n      if(routeMatch){\n        res.send('MATCH EDIT: ' + routeMatch.params.editpath);\n        return false;\n      }\n      \n      return res.send(req.originalUrl);\n      \n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-27T08:23:10.760Z",
  "updatedAt": "2019-04-06T03:55:22.851Z",
  "nodes": []
}