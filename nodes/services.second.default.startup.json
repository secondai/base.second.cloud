{
  "name": "base.second.cloud.services.second.default.startup",
  "type": "types.second.default.service.js",
  "data": {
    "key": "caa31b79-0ffc-417a-b7cc-9ed5d61332a6",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n  \n      console.log('Incoming Startup (setup, server, etc)');\n      \n      console.log('Startup INPUT:', INPUT);\n      \n      // INPUT = {\n      //   type: 'types.second.default.startup_input',\n      //   data: {\n      //     didPopulate: false,\n      //     needsBuild: false,\n      //   }\n      // }\n      \n      // // Start Express Server  \n      // await universe.loadAndRunCapability('ExpressServer',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'setup',\n      //     options: {}\n      //   }\n      // });\n    \n      let doneCanWipe;\n      universe.wipeFunc = new Promise(resolve=>{\n        doneCanWipe = resolve;\n      });\n      \n      // Create \"owner\" node if doesn't already exist \n      let ownerNode = await universe.getNodeAtPath('private.auth.owner');\n      if(!ownerNode){\n        console.log('Owner node does NOT exist, creating');\n        await universe.putNodeAtPath('private.auth.owner',{\n          type: 'types.second.default.auth.owner',\n          data: {\n            passphrase: universe.env.DEFAULT_PASSPHRASE\n          }\n        });\n        console.log('Created owner node w/ default passphrase');\n        ownerNode = await universe.getNodeAtPath('private.auth.owner');\n      }\n      \n      // Run \"build all\" if needs it \n      // if(INPUT \n      //   && (INPUT.type == 'types.second.default.startup_input')\n      //   && INPUT.data\n      //   && INPUT.data.needsBuild){\n      if(INPUT && INPUT.data && INPUT.data.needsBuild){\n        \n        let expectedBuildTypes = [\n          'types.second.default.app',\n          'types.second.default.code.js',\n          'types.second.default.service.js',\n          'types.second.default.permissions',\n          'types.second.default.route'\n        ];\n\n        // Run build for all paths that need it\n  \t\t  const Op = universe.sharedServices.db.Sequelize.Op; \n        let whereQuery = {\n          type: {\n            [Op.in]: expectedBuildTypes\n          },\n          name: {\n            [Op.notLike]: 'base.%'\n          }\n        }\n  \t\t  let nodes = await universe.sharedServices.db.Node.findAll({\n  \t\t    where: whereQuery,\n  \t\t    raw: true,\n  \t\t  });\n  \t\t  \n  \t\t  let nodesToBuild = nodes.filter(n=>{\n  \t\t    return (n.data && n.data.src)\n  \t\t  });\n  \t\t  \n  \t\t  console.log('Nodes to build with (run build.buildOnInstall):', nodesToBuild.map(n=>n.name));\n        \n        // Build each path \n        \n        for(let node of nodesToBuild){\n          console.log('Building:', node.name);\n          await universe.execService('services.second.default.bin.build', {\n            actionPath: 'builtin.input',\n            inputNode: {\n              type: 'types.second.default.bin.install.build ',\n              data: {\n                nodePath: node.name,\n                target: 'onInstall',\n                opts: {\n                  containerOrCode: 'all' // default: 'all'\n                }\n              }\n            },\n            isOwner: true\n          });\n        }\n  \t\t  \n        \n      }\n      \n      \n      // Start Express Server  \n\t\t\tawait universe.execService('services.second.default.capability.server', {\n        actionPath: 'builtin.input',\n        inputNode: {},\n        isOwner: true\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\t// Start IPFS watcher\n\t\t\tawait universe.execService('services.second.default.capability.ipfs', {\n        actionPath: 'builtin.input',\n        inputNode: {},\n        isOwner: true\n\t\t\t});\n\t\t\t\n\t\t// \tTODO: \n\t\t// - start Scheduler \n\t\t// - start Websocket server \n\t\t\t\n\t\t\t\n    \n      \n      // // Start Websocket (socketio) server \n      // let websocketSetupServerResult = await universe.loadAndRunCapability('Websockets',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'setupServer',\n      //     options: {}\n      //   }\n      // });\n      // console.log('Websocket serverSetup Result:', websocketSetupServerResult);\n        \n      // // connect to IPFS and re-setup IPFS links (identity is most important) \n      // var ipfsSetupResult = await universe.loadAndRunCapability('IPFS',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'setup',\n      //     options: {\n      //     }\n      //   }\n      // });\n      // var ipfsSyncResult = await universe.loadAndRunCapability('IPFS',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'sync',\n      //     options: {\n      //     }\n      //   }\n      // });\n    \n      // // Start Scheduler \n      // await universe.loadAndRunCapability('Scheduler',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {}\n      //   }\n      // });\n      \n      \n      \n      \n      return resolve({\n        type: 'boolean:...',\n        data: true\n      });\n      \n      \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-05T22:28:56.765Z",
  "updatedAt": "2019-03-20T05:19:40.936Z",
  "nodes": []
}