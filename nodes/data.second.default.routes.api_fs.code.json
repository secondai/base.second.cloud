{
  "name": "base.second.cloud.data.second.default.routes.api_fs.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--API Filesystem (for a PATH): --', SELF.name);\n      \n      const fs = universe.require('fs-extra');\n      const path = universe.require('path');\n      \n      // This is just temporary! \n      let {\n        req,\n        res\n      } = INPUT.data;\n      \n      let bodyNode = req.body || {\n        type: 'types.second.default.fs_api',\n        data: {\n          opts: {\n            pattern: '*',\n            ignore: [\n              // '**/node_modules/**',\n              // 'frontend/node_modules',\n              // 'frontend/node_modules/**',\n              // '{,!(node_modules)/**}'\n            ],\n            gitignore: false,\n            stats: true, // (NOT-NOW ignored)\n            onlyFiles: false,\n            onlyDirectories: false\n          }\n        }\n      }\n      // console.log('bodyNode:', bodyNode);\n      \n      let pathToRegExp = universe.require('path-to-regexp');\n      function matchRoute(route){\n        let keys = [];\n        let re = pathToRegExp(route, keys)\n        let matches = re.exec(req.originalUrl)\n        if(!matches){\n          return null;\n        }\n        let params = {};\n        keys.forEach((key, i)=>{\n          params[key.name] = matches[i + 1];\n        });\n        return {\n          route,\n          params\n        };\n      }\n      \n      let routePath;\n      let routeMatch;\n      routePath = '/api/fs/:action/:path*';\n      routeMatch = matchRoute(routePath) || {params:{}};\n      \n      console.log('routeMatch:', routeMatch);\n      if(!routeMatch){\n        console.error('Missing action and path in /api/fs/:action/:path');\n        return false;\n      }\n      \n      let _PATH = routeMatch.params.path;\n      let fsCmd = routeMatch.params.action;\n      let fsOpts = bodyNode.data ? bodyNode.data.opts : {};\n      \n      let appPath = _PATH.split('/')[0];\n      \n      // console.log('fsCmd:', fsCmd);\n      // console.log('fsPath:', _PATH);\n      // console.log('fsOpts:', fsOpts);\n      \n      let fromPath;\n      let toPath;\n          \n      let result = {};\n      \n      // Find cmd and run  \n      try {\n          \n        switch(fsCmd){\n          case 'get':\n          case 'readFileSync':\n            // console.error('NOT READY');\n            res.sendFile(path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH), {dotfiles: 'allow'} );\n            return;\n            break;\n            \n          case 'putText':\n            // console.error('NOT READY');\n            // console.log('putText in api_fs', universe.env.ATTACHED_VOLUME_ROOT + _PATH, fsOpts.text);\n            result = fs.writeFileSync(path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH), fsOpts.text, 'utf8');\n            res.send({data: result});\n            return;\n            break;\n            \n          case 'globby':\n            let globby = universe.require('globby');\n            fsOpts = universe.lodash.defaults({},{\n              // force \n              cwd: path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH),\n              // stats: false,\n              followSymlinkedDirectories: false\n            },\n            bodyNode.data.opts,\n            {\n              gitignore: false,\n              expandDirectories: true,\n              dot: true,\n              onlyFiles: false,\n              onlyDirectories: false,\n              markDirectories: true\n              // stats: false\n            });\n            console.log('globby cwd:', fsOpts.cwd);\n            let matches;\n            try {\n              matches = await globby(fsOpts.pattern, fsOpts)\n            }catch(err){\n              console.log('Failed globby');\n              matches = [];\n            }\n            result = matches.map(m=>{\n              return {\n                path: m.path,\n                isDir: m.isDirectory() || undefined,\n                isFile: m.isFile() || undefined,\n                isSocket: m.isSocket() || undefined,\n              }\n            });\n            result = {\n              type: 'array',\n              data: result\n            }\n            break;\n            \n          case 'rename':\n            fromPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH);\n            toPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, appPath, fsOpts.to);\n            \n            console.log(fromPath, toPath);\n            result = await fs.rename(fromPath, toPath);\n            result = {\n              type: 'string',\n              data: result\n            }\n            console.log('Renamed'); //, result);\n            break;\n            \n          case 'move':\n            fromPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH);\n            toPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, appPath, fsOpts.to);\n            \n            result = await fs.move(fromPath, toPath);\n            result = {\n              type: 'string',\n              data: result\n            }\n            break;\n            \n          case 'copy':\n            fromPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH);\n            toPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, appPath, fsOpts.to);\n            \n            result = await fs.copy(fromPath, toPath);\n            result = {\n              type: 'string',\n              data: result\n            }\n            break;\n            \n          case 'remove':\n            fromPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH);\n            result = await fs.remove(fromPath);\n            result = {\n              type: 'string',\n              data: result\n            }\n            break;\n            \n          case 'ensureDir':\n            fromPath = path.join(universe.env.ATTACHED_VOLUME_ROOT, _PATH);\n            result = await fs.ensureDir(fromPath);\n            result = {\n              type: 'string',\n              data: result\n            }\n            break;\n            \n          case 'stat':\n            console.error('NOT READY');\n            break;\n            \n          default:\n            console.error('Invalid cmd', req.body);\n            result = {\n              type: 'types.second.default.error',\n              error: true,\n              message: 'Invalid cmd'\n            }\n            break;\n        }\n      }catch(err){\n        console.error(err);\n        res.status(404);\n        result = {\n          error: true,\n          type: 'types.second.default.error',\n          message: 'Failed command'\n        }\n      }\n      \n      res.send(result);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-20T23:53:09.551Z",
  "updatedAt": "2019-03-20T23:53:09.551Z",
  "nodes": []
}