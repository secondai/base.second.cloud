{
  "name": "base.second.cloud.services.second.default.input",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--service:', SELF._path, '--', PATH);\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let secondResponseNode;\n      let bodyNode = INPUT;\n      \n      // console.log('bodyNode', bodyNode);\n      \n      // bodyNode MUST be in a standard format that we can convert for execService w/ a valid auth obj \n      // - TODO: validate \n      if(bodyNode.type != 'types.second.default.request.input'){\n        console.error('Invalid bodyNode.type! Expecting \"types.second.default.request.input\" and received:', bodyNode.type);\n        return {\n          type: 'types.second.default.error',\n          data: {\n            error: true,\n            message: 'Invalid bodyNode.type! Expecting \"types.second.default.request.input\"'\n          }\n        }\n      }\n      \n      let {\n        auth,\n        serviceName,\n        actionPath,\n        inputNode,\n        extras // for auth_additions (dynamic additions for request, could be just about anything?) \n      } = bodyNode.data;\n      \n      // bodyNode = {\n      //   type: \"types.second.default.request.input\",\n      //   data: {\n      //     serviceName: 'services.second.default.get',\n      //     actionPath: 'data.second.default.blogposts.xyz',\n      //     inputNode: {\n      //       ...\n      //     },\n      //     auth: {\n      //       token: \n      //     }\n      //   }\n      // }\n      \n      \n      // convert incoming authObj w/ token\n      let token = auth ? auth.token:null;\n      if(!token){\n        console.log('Missing bodyNode.data.auth.token (anonymous)');\n        // return false;\n      }\n      \n      // validate token (no dots, etc.) \n      if(token){\n        token = token.split('.').join('');\n      }\n      \n      // convert token to permissions object \n      let authNode;\n      if(token){\n        authNode = await universe.getNodeAtPath(`tokens.auth.${token}`, {lean: true, fields: ['_path','type','data']});\n        if(!authNode){\n          console.error('Failed to find authNode/user for supplied token');\n        } else {\n          // Found matching authNode using token \n          // - get permission node too \n          let permissionsNode = await universe.getNodeAtPath(`tokens.auth.${token}.permissions`, {lean: true, fields: ['type','data']});\n          try {\n            authNode.permissions = permissionsNode.data.permissions;\n          }catch(err){\n            console.error('Missing permissions node for token:', token);\n          }\n        }\n      }\n      \n      if(!authNode){\n        // change to an anonymous user \n        // - TODO: respond with invalid/expired auth \n        console.log('Using an anonymous user');\n        authNode = {\n          type: 'builtin.auth',\n          data: {\n            isOwner: false\n          },\n          extras: {}, // for additional key-value entries, that can be used by the permissions (groups, etc?) \n          permissions: [], // should be a node w/ name=\"permissions\" in authObj.nodes[] (permissionsNode.data.permissions)\n          // nodes: [{\n          //   name: 'permissions',\n          //   type: 'types.second.default.permissions',\n          //   data: {\n          //     permissions: []\n          //   }\n          // }]\n        }\n      } else {\n        console.log('using supplied authNode!');\n      }\n      \n      \n    //   // checkPermissions using \"pre\" event \n  \t\t// let permissionResult = await funcInSandbox.universe.checkPermission({\n  \t\t// \teventName: 'pre', // 'std.second.permission_type.before_service_run',\n  \t\t// \tserviceName,\n  \t\t// \tactionPath,\n  \t\t// \tinputNode,\n  \t\t// \tauthNode\n  \t\t// });\n  \t\t// if(permissionResult === true){\n\n  \t\t// } else {\n    //     // not allowing\n    //     console.error('--Not allowed!!--');\n    //     return false;\n  \t\t// }\n  \t\t\n  \t\t// Service exists? \n  \t\tlet serviceNode = await universe.getNodeAtPath(serviceName);\n  \t\tif(!serviceNode){\n  \t\t\tsecondResponseNode = {\n  \t\t\t  type: 'types.second.default.response.error',\n  \t\t\t  data: {\n  \t\t\t    errorCode: 1,\n  \t\t\t    message: 'Invalid service name, unavailable'\n  \t\t\t  }\n  \t\t\t}\n        await universe.httpResponse('send', secondResponseNode);\n  \t\t  return resolve(secondResponseNode);\n  \t\t}\n  \t\t\n  \t\t\n  \t\t// run execService \n\t\t\tlet resultNode = await universe.execService(serviceName, {\n\t\t\t  actionPath,\n\t\t\t  inputNode,\n\t\t\t\tauthNode\n\t\t\t});\n\t\t\t\n\t\t// \tconsole.log('Got secondResponseNode from execService in /ai!');\n\t\t\t\n\t\t\t// wrap output each time \n\t\t\tsecondResponseNode = {\n\t\t\t  type: 'types.second.default.response',\n\t\t\t  data: (resultNode === undefined) ? null:resultNode\n\t\t\t}\n      \n      return resolve(secondResponseNode);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "description": "Default handler for an input coming in"
  },
  "blobdata": null,
  "createdAt": "2019-03-05T06:16:15.680Z",
  "updatedAt": "2019-03-17T21:50:11.575Z",
  "nodes": []
}