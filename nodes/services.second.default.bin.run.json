{
  "name": "base.second.cloud.services.second.default.bin.run",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--Service --', SELF.name, '--');\n      \n      const util = universe.require('util');\n      const { spawn } = universe.require('child_process');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n      \n      // function StreamingResponse(){\n        \n      //   let streamId = universe.uuidv4();\n      //   this.createdAt = Date.now();\n      //   this.streamId = streamId;\n      //   this.responses = [];\n        \n      //   // make available in universe \n      //   universe.sharedServices.streaming_responses = universe.sharedServices.streaming_responses || {};\n      //   universe.sharedServices.streaming_responses[streamId] = this;\n      //   // let streamResponse = universe.sharedServices.streaming_responses[streamId];\n        \n      // }\n      // StreamingResponse.prototype.streamId = function(){\n      //   return this.streamId;\n      // }\n      \n      // StreamingResponse.prototype.add = function(val){\n      //   return this.responses.push(val);\n      // }\n      \n      // StreamingResponse.prototype.slice = function(start, end){\n      //   return this.responses.slice(start, end);\n      // }\n      \n      // StreamingResponse.prototype.close = function(val){\n      //   delete universe.sharedServices.streaming_responses[this.streamId];\n      // }\n      \n      // universe.sharedServices.StreamingResponse = StreamingResponse; //universe.sharedServices.StreamingResponse || StreamingResponse;\n\n\n      // INPUT\n      // type: types.second.default.bin.install.run \n      // data: {\n      //   nodePath,\n      //   target, // default: self\n      //   opts\n      // }\n      \n      // TODO: for errors, universe.isError() quick-checker against registered error types \n      \n        \n      let allowedBuildTypes = [\n        'types.second.default.app',\n        'types.second.default.code.js',\n        'types.second.default.service.js',\n        'types.second.default.permissions',\n        'types.second.default.route'\n      ];\n      \n      let {\n        nodePath,\n        target, // \"all\", \"onInstall\" (buildOnInstall:true), self, other\n        opts\n      } = INPUT.data;\n      \n      nodePath = nodePath || PATH;\n      \n      target = target || 'self'; \n      opts = opts || {};\n      opts = universe.lodash.defaults({},opts,{\n        command: null\n      });\n      \n      console.log('Build Opts.command:', opts.command);\n      \n      // Find appNode \n      node = await universe.getNodeAtPath(nodePath);\n      if(!node){\n        console.error('Missing node for build');\n        return resolve({\n          error: true,\n          message: 'Missing Node'\n        });\n      }\n      \n      if(allowedBuildTypes.indexOf(node.type) === -1){\n        console.error('Invalid type for build');\n        return resolve({\n          error: true,\n          message: 'Invalid type of node'\n        });\n      }\n      \n      \n      let doneCanWipe;\n      universe.wipeFunc = new Promise(resolve=>{\n        doneCanWipe = resolve;\n      });\n      \n      // creating streaming response \n      console.log('==-=-=-=-=-=-=-=-=-=SharedServices:', Object.keys(universe.sharedServices || {}));\n      let streamResponse = new universe.sharedServices.StreamingResponse();\n      \n      streamResponse.add({\n        type: 'init',\n        data: null\n      });\n      \n      // TODO: \n      // - pushToStream (use websockets to push to a stream) \n      \n      resolve({\n        type: 'types.second.default.response.streaming',\n        data: {\n          streamId: streamResponse.streamId\n        }\n      });\n      \n      // deleted after an expiration period \n      // - TODO: move to long-term storage (in DB?) \n      \n      \n      let targets = [];\n      switch(target){\n        case 'all':\n          targets = Object.keys(node.data.src).filter(k=>{\n            return node.data.src.hasOwnProperty(k);\n          });\n          break;\n          \n        default:\n          targets = universe.lodash.isArray(target) ? target:[target];\n      }\n      \n      console.log('Targets:', target, targets.length, targets);\n      \n      let runResults = [];\n      \n      for(let target of targets){\n        \n        console.log('TARGET:',target);\n        \n        let runResult = {};\n        \n        // Check for \"self\" or other \n        if(!node.data.src[target]){\n          console.error('Missing target for build');\n          runResult = {\n            target,\n            error: true,\n            message: 'Missing target'\n          };\n          runResults.push(runResult);\n          continue;\n        }\n        \n        // Check for valid command \n        if(!node.data.src[target].commands || !node.data.src[target].commands.hasOwnProperty(opts.command)){\n          console.error('Missing target command:', opts.command);\n          runResult = {\n            target,\n            error: true,\n            message: 'Missing target.command',\n            command: opts.command\n          };\n          runResults.push(runResult);\n          continue;\n        }\n        \n        let actualCommand = node.data.src[target].commands[opts.command];\n        \n        var subDirectory = node.data.src[target].src.targetDir || '/';\n        \n        // Using for container/code building \n        var DBUILDER_IMAGE = node.data.src[target].build.image;\n        var DBUILDER_CONTAINER = node.data.src[target].build.container || 'second-container-code-' + node.name + '-' + Date.now();\n        \n        // using for Image building \n        var DBUILDER_CONTEXT = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory); // path for dockerfile? \n        var DBUILDER_DOCKERFILE = node.data.src[target].build.dockerfile || ''; //'dockerfile.second'; \n        var DBUILDER_WORKDIR = DBUILDER_CONTEXT; \n        \n        var DBUILDER_DOCKERFILE_PATH = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory, DBUILDER_DOCKERFILE);\n        \n        // Run commands \n        \n        let consoleOutput = [];\n        try {\n          \n          var execCommand;\n          \n          // --cpus=\"0.8\" \n          // --cpu-shares 512 --cpuset-cpus=0\n          execCommand = `docker run --volumes-from nodejs ${DBUILDER_IMAGE} /bin/bash -c \"cd ${DBUILDER_CONTEXT} && ${actualCommand}\"`;\n          \n          console.log('Running command:', execCommand);\n          \n          // var { stdout, stderr } = await exec(command);\n        \n          // console.error('------------------------------');\n          // console.error(`---exec error:`, stderr);\n          // console.error('------------------------------');\n          \n          // console.log('------------------------------');\n          // console.log(`---exec Run Output:`, stdout);\n          // console.log('------------------------------');\n          \n          // consoleOutput.push({stderr});\n          // consoleOutput.push({stdout});\n          var child = spawn(execCommand, {shell: true, stdio_: 'inherit'});\n          child.stdout.on('data', (data) => {\n            console.log(`CHILD stdout: ${data}`);\n            streamResponse.add({\n              type: 'update-stdout',\n              data: data.toString()\n            });\n            consoleOutput.push({stdout: data.toString()});\n          });\n          child.stderr.on('data', (data) => {\n            console.error(`CHILD stderr: ${data}`);\n            streamResponse.add({\n              type: 'update-stderr',\n              data: data.toString()\n            });\n            consoleOutput.push({stderr: data.toString()});\n          });\n          var resolveExit;\n          var onExit = new Promise(r=>{resolveExit=r});\n          child.on('exit', function (code, signal) {\n            console.log(`CHILD2 process exited with code ${code} and signal ${signal}`);\n            streamResponse.add({\n              type: 'update-exit',\n              data: {\n                code,\n                signal\n              }\n            });\n            resolveExit();\n          });\n            \n          await onExit;\n          \n          runResult = {\n            error: false,\n            target,\n            consoleOutput\n          };\n          runResults.push(runResult);\n          \n          streamResponse.add({\n            type: 'update',\n            data: {\n              type: 'console_output',\n              data: consoleOutput\n            }\n          });\n          \n        }catch(err){\n          console.error('Failed Command',err);\n          // resolve({\n          //   error: true,\n          //   message: 'Failed',\n          //   err\n          // });\n          // return false;\n          \n          runResult = {\n            target,\n            error: true,\n            message: 'Failed command',\n            consoleOutput\n          };\n          runResults.push(runResult);\n          continue;\n        }\n      }\n      \n      console.log('Done Running');\n      // resolve({\n      //   type: 'types.second.default.bin.run.output',\n      //   data: {\n      //     runResults\n      //   }\n      // })\n      \n      streamResponse.add({\n        type: 'complete',\n        data: {\n          type: 'types.second.default.bin.run.output',\n          data: {\n            runResults\n          }\n        }\n      });\n      \n      // End stream \n      universe.setTimeout(()=>{\n        streamResponse.close();\n        doneCanWipe();\n      }, 2 * 60 * 1000); // 2 minutes\n      \n      return false;\n    \n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-04-03T21:35:07.848Z",
  "updatedAt": "2019-04-06T03:53:58.725Z",
  "nodes": []
}