{
  "name": "base.second.cloud.app.second.deveditor.frontend.data.react_components.main.developer_window.left_file_browser",
  "type": "types.second.default.react_component.js",
  "data": {
    "code": "(()=>{\n  \n    //takes an array of JavaScript File objects\n  function getFiles(fileList) {\n      return Promise.all(Object.keys(fileList).map(fileIdx => getFile(fileList[fileIdx])));\n  }\n\n  //take a single JavaScript File object\n  function getFile(file) {\n      var reader = new WINDOW.FileReader();\n      return new Promise((resolve, reject) => {\n          reader.onerror = () => { reader.abort(); reject(new Error(\"Error parsing file\"));}\n          reader.onload = function () {\n\n              //This will result in an array that will be recognized by C#.NET WebApi as a byte[]\n              let bytes = Array.from(new WINDOW.Uint8Array(this.result));\n\n              //if you want the base64encoded file you would use the below line:\n              let base64StringFile = WINDOW.btoa(bytes.map((item) => String.fromCharCode(item)).join(\"\"));\n\n              //Resolve the promise with your custom file structure\n              resolve({ \n                  bytes: bytes,\n                  base64StringFile: base64StringFile,\n                  name: file.name, \n                  type: file.type\n              });\n          }\n          reader.readAsArrayBuffer(file);\n      });\n  }\n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n    \n  function matchRuleShort(str, rule) {\n    return new RegExp(\"^\" + rule.split(\"*\").join(\".*\") + \"$\").test(str);\n  }\n  \n  function pathMatch(path, pattern){\n    // pattern: xyz.%.%.* something \n    \n    let pathSplit = path.split('.');\n    let patternSplit = pattern.split('.');\n  \n    let doesMatch = false;\n    let stopCheckingPathCuzFailed;\n    pathSplit.forEach((name,idx)=>{\n      if(stopCheckingPathCuzFailed){\n        return;\n      }\n  \n      let isLastName = (idx == (pathSplit.length - 1)) ? true:false;\n      let isLastPattern = (idx == (patternSplit.length - 1)) ? true:false;\n  \n      let patternForSegment = patternSplit[idx];\n  \n      // console.log('name', name);\n      // console.log('pattern', pattern);\n      // console.log('isLast', isLast);\n  \n      if(patternForSegment == '**'){\n        // console.log('Match **');\n        stopCheckingPathCuzFailed = true;\n        doesMatch = true;\n        return;\n      }\n      \n      if(patternForSegment == '' && isLastName && isLastPattern){\n        // same as \".*\"\n        doesMatch = true;\n        return;\n      }\n      \n      if(typeof patternForSegment != 'string'){\n        // failed\n        stopCheckingPathCuzFailed = true;\n        return;\n      }\n  \n      if(matchRuleShort(name, patternForSegment)){\n        if(isLastName){\n          if(isLastPattern){\n            doesMatch = true;\n          } else {\n            // not a match \n            stopCheckingPathCuzFailed = true;\n          }\n        } else {\n          // just continue to checking the next part of this path! \n          // console.log('continue checking');\n        }\n      } else {\n        stopCheckingPathCuzFailed = true;\n      }\n  \n    })\n  \n    return doesMatch;\n    \n  }\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            expandedPaths: {}, // directories we have expanded\n            // allPaths: {}, // props.state.allPaths!\n            fetchingPaths: {},\n            selectedPath: null,\n            hiding: {},\n            text: '',\n            pastable: false,\n            pasteText: '',\n            showChildren: true\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteFiles();\n          \n          universe.EE.on('files-modified', this.fetchRemoteFiles);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('files-modified', this.fetchRemoteFiles);\n        }\n        \n        @autobind\n        fetchRemoteFiles(){\n          return new Promise(async (resolve,reject)=>{\n            console.log('Fetching remote files');\n            try {\n              await this.fetchRemoteFilesAtPath('/');\n              this.setState({\n                invalidRoot: false\n              });\n              \n              for(let path of Object.keys(this.state.expandedPaths)){\n                // console.log('Also Path:', path);\n                try {\n                  await this.fetchRemoteFilesAtPath(path);\n                }catch(err){\n                  // remove expandedPath \n                  console.error('Failed finding path:', path);\n                }\n              }\n              \n            }catch(err){\n              // failed default path, create? \n              console.error('Root not created');\n              this.props.setState({\n                allPaths: {}\n              });\n              this.setState({\n                expandedPaths: {},\n                invalidRoot: true\n              });\n            }\n              \n          })\n        }\n        \n        @autobind\n        fetchRemoteFilesAtPath(filepath){\n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState(state=>{\n                let fetchingPaths = state.fetchingPaths;\n                fetchingPaths[filepath] = true;\n                return {\n                  fetchingPaths\n                }\n              })\n              \n              universe.$.ajax({\n                url: '/api/fs/globby/' + this.props.state.editingNode.name + filepath,\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  type: '',\n                  data: {\n                    opts: {\n                      pattern: '*',\n                      ignore: [\n                        // '**/node_modules/**',\n                        // 'frontend/node_modules',\n                        // 'frontend/node_modules/**',\n                        // '{,!(node_modules)/**}'\n                      ],\n                      gitignore: false,\n                      stats: true, // (NOT-NOW ignored)\n                      onlyFiles: false,\n                      onlyDirectories: false\n                    }\n                  }\n                }),\n                success: result=>{\n                  // console.log('Got result from /globby get!'); //, result);\n                  \n                  let files = {};\n                  for(let fresult of result.data){\n                    files[filepath + fresult.path] = {\n                      path: filepath + fresult.path, // get full path (returned a relative path) \n                      isDir: fresult.isDir,\n                      isFile: fresult.isFile\n                    } //fresult;\n                  }\n                  \n                  // console.log('Files downloaded using globby:', result, files);\n                  \n                  let allPaths = JSON.parse(JSON.stringify(this.props.state.allPaths || {}));\n                  // let expandedPaths = JSON.parse(JSON.stringify(this.state.expandedPaths || {}))\n                  \n                  // remove missing/deleted \n                  let toRemove = [];\n                  for(let fpath of Object.keys(allPaths)){\n                    // console.log('allPaths fpath:', fpath);\n                    if(fpath.indexOf(filepath) === 0 \n                      && (\n                        (fpath.split('').pop() != '/' && fpath.split('/').length == (filepath.split('/').length)) // files\n                        ||\n                        (fpath.split('').pop() == '/' && fpath.split('/').length == (filepath.split('/').length + 1)) // folders (trailing slash)\n                      )){\n                      // direct child (remove,, update?) \n                      // console.log('direct child:', filepath, fpath);\n                      // exists in results? \n                      if(files[fpath]){\n                        // continue on \n                        // console.log('exists still', fpath);\n                      } else {\n                        // no longer exists! \n                        // - remove from allPaths \n                        // toRemove.push(fpath);\n                        console.log('Clearing file/folder frow showing:', fpath);\n                        \n                        // remove all potential expanded paths \n                        // TODO \n                        \n                        delete allPaths[fpath];\n                      }\n                    } else {\n                      // console.log('not child:', fpath, filepath);\n                    }\n                  }\n                  \n                  // add/update \n                  for(let fpath of Object.keys(files)){\n                    allPaths[fpath] = files[fpath];\n                  }\n                  \n                  // console.log('allPaths:', allPaths);\n                  \n                  // this.setState({\n                  //   // expandedPaths,\n                  //   allPaths\n                  // });\n                  \n                  // console.log('files:', files);\n                  \n                  // let componentNode = await universe.runInVM(result[0],{});\n                  this.setState(state=>{\n                    let fetchingPaths = state.fetchingPaths;\n                    fetchingPaths[filepath] = false;\n                    return {\n                      fetchingPaths\n                    }\n                  })\n                  \n                  \n                  this.props.setState({\n                    allPaths,\n                    selectedPaths: []\n                  })\n                  \n                  resolve();\n                  \n                },\n                error: errr=>{\n                  \n                  console.error('Failed to /globby');\n                    \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  reject();\n                  \n                  // WINDOW.alert('Failed to /get');\n                }\n              });\n              \n              \n              \n            } catch(err){\n              console.error('Failed getting files for path');\n              \n              reject();\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n        \n        @autobind\n        fetchRemoteSingleNodeNew(nodePath){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              return false;\n              \n              \n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              \n              \n              universe.$.ajax({\n                url: '/api/get',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({name: nodePath}),\n                success: result=>{\n                  // console.log('Got result from /get!', result);\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = universe.cJSON.parse(result);\n                  \n                  // console.log('Node Got:', node);\n                  \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  return resolve(node);\n              \n                },\n                error: err=>{\n                    \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  reject();\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n              \n            } catch(err){\n              console.error('Failed getting local single node');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n      \n        @autobind\n        handleNewFile(){\n      \n          return new Promise(async (resolve,reject)=>{\n        \n            let name = WINDOW.prompt('Name (blank for random, replace % with UUID)','');\n            if(typeof name != 'string'){\n              console.log('canceled');\n              return false;\n            }\n            \n            name = name.trim();\n            \n            if(name == ''){\n              name = universe.uuidv4();\n            }\n            \n            name = name.replace(/\\%/g,()=>{\n              return universe.uuidv4();\n            });\n            \n            console.log('name:', name);\n            \n            \n            let type;\n            type = WINDOW.prompt('Type (types.second.default.code)','types.second.default.x');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forcePutNode(name, newNode);\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('files-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('files-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        forcePutNode(name, nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', name, nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              universe.$.ajax({\n                url: '/api/put',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  name,\n                  type: nodeToSave.type, \n                  data: nodeToSave.data\n                }),\n                success: result=>{\n                  console.log('Got result from /api/put!', result);\n                  \n                  if(skipEvent !== true){\n                    try {\n                      universe.EE.emit('files-modified', '');\n                    }catch(err){\n                      console.error(err);\n                    }\n                  }\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = result;\n                  \n                  return resolve(node);\n              \n                },\n                error: errr=>{\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n            } catch(err){\n              console.error('Failed forcePutNode', err);\n              \n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('files-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async handleCreateInvite(){\n          \n          let inviteCode = universe.uuidv4();\n          \n          let name = WINDOW.prompt('Note for invite code?', '');\n          if(!name){\n            return false;\n          }\n          \n          let network = WINDOW.prompt('Network (public or test)', 'test');\n          if(network != 'public' && network != 'test'){\n            return false;\n          }\n          \n          inviteCode = WINDOW.prompt('Invite Code (should be unique!)', inviteCode);\n          if(!inviteCode){\n            return false;\n          }\n          \n          // TODO: \n          // - uniqueness check/constraint \n        \n          let newNode = {\n            name: universe.uuidv4(),\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324', // invite\n            data: {\n              name,\n              inviteCode,\n              network,\n              sourcePublicKey: null,\n              accepted: false,\n              uploadBytes: 0\n            }\n          }\n          \n          console.log('new invite node:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode);\n            \n          WINDOW.prompt('Invite Created!', inviteCode);\n            \n        }\n        \n        @autobind\n        async handleClickFileOrDirectory(fPath, e){\n          \n          if(e.shiftKey){\n            // select multiple \n            let selectedPaths = this.props.state.selectedPaths || [];\n            let idx = selectedPaths.indexOf(fPath.path);\n            if(idx > -1){\n              selectedPaths.splice(idx,1);\n            } else {\n              selectedPaths.push(fPath.path);\n            }\n            \n            this.props.setState({\n              editingFilePath: null,\n              selectedPaths\n            })\n            \n            WINDOW.document.getSelection().removeAllRanges();\n            \n          } else {\n            \n            // build editingFilePath (without circular references) \n            \n            if(fPath.isDir){\n              // expand directory \n              // - find files for it \n              \n              let expandedPaths = this.state.expandedPaths;\n              if(expandedPaths[fPath.path]){\n                // expanded already (collapse)  \n                delete expandedPaths[fPath.path];\n                this.setState({\n                  expandedPaths\n                });\n              } else {\n                // expand! \n                expandedPaths[fPath.path] = true;\n                this.setState({\n                  expandedPaths\n                });\n                \n                this.fetchRemoteFilesAtPath(fPath.path);\n              }\n              \n              // this.props.setState({\n              //   editingFilePath,\n              //   selectedPaths: []\n              // })\n              \n            } else if(fPath.isFile) {\n              \n              let editingFilePath = fPath.path;\n              \n              this.props.setState({\n                editingFilePath,\n                selectedPaths: []\n              })\n              \n            }\n            \n          }\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              // function addChildren(id){\n              //   return new Promise(async (resolve,reject)=>{\n            \n              //     let nodes = [];\n              //       for(let filepath of Object.keys(allFiles)){\n              //         console.log('addChildren:', filepath);\n              //         let contents = allFiles[filepath];\n              //         if(filepath.indexOf('nodes/') !== 0){\n              //           // console.log('NOT NODE:', filepath);\n              //           continue;\n              //         }\n        \n              //         let parsed = jsonParse(filepath, contents);\n              //         if(parsed.nodeId == id){\n              //           // console.log('Matches ID:', parsed.nodeId, id);\n              //           let children = await addChildren(parsed._id);\n              //           parsed.nodes = children;\n              //           nodes.push(parsed);\n              //         } else {\n              //         // console.log('No Kids:', id, parsed.nodeId);\n              //       }\n      \n              //     }\n      \n              //     resolve(nodes);\n      \n              //   });\n              // }\n              \n              function addChildren(path){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  try {\n                      \n                    for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf(path) !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n                      let pathDepth = path.split('/').length;\n                      let filepathDepth = filepath.split('/').length;\n                      if(pathDepth == filepathDepth){\n                        // xyz.json at correct depth\n                        \n                        let parsed = jsonParse(filepath, contents);\n                        // if(parsed.nodeId == id){\n                          // console.log('Matches ID:', parsed.nodeId, id);\n                          let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                          parsed.nodes = children;\n                          nodes.push(parsed);\n                        // } else {\n                        //   // console.log('No Kids:', id, parsed.nodeId);\n                        // }\n                      }\n        \n        \n                    }\n                  }catch(err){\n                    console.error(err);\n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                // ZipNodes = await addChildren(null); // start at root, adds children recursively\n                ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  name: node.name,\n                  nodeId: null, // saving to root-level!\n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        name: tmpNode.name,\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('rebuilding memory on remote, after bulk updates');\n              // await this.makeRebuildMemoryRequest();\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('files-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              name: node.name || universe.uuidv4(),\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    name: tmpNode.name || universe.uuidv4(),\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('files-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        async handleEnsureRoot(){\n          \n                  \n          let apiUrl = '/api/fs/ensureDir/' + this.props.state.editingNode.name + '/';\n          let fsOpts = {\n            // prevent overwrite? \n          }\n          \n          let fsResult = await this.runFsCommand(apiUrl, fsOpts);\n          \n          this.fetchRemoteFiles();\n          \n        }\n        \n        @autobind\n        async handleRightClickFs(e, data){\n           console.log('Data:', data);\n           \n           // TODO: react element that can be passed data to collect (messages, input handlers, etc) \n           \n          let defaultInput = data.path;\n          let inputActionText = 'Save';\n          \n          let pathDirName = data.path.split('/');\n          pathDirName.pop();\n          pathDirName = pathDirName.join('/');\n          \n           // Open dialog for path change\n          let inputMessage;\n          switch(data.cmd){\n            case 'rename':\n              inputMessage = 'Rename: ' + data.path;\n              inputActionText = 'Rename';\n              break;\n              \n            case 'move':\n              inputMessage = 'Move: ' + data.path;\n              inputActionText = 'Move';\n              break;\n              \n            case 'copy':\n              inputMessage = 'Copy: ' + data.path;\n              inputActionText = 'Copy';\n              break;\n              \n            case 'new-dir':\n              inputMessage = 'New Directory';\n              defaultInput = pathDirName + '/';\n              inputActionText = 'Create';\n              break;\n              \n            case 'new-file':\n              inputMessage = 'New File';\n              defaultInput = pathDirName + '/xyz.txt';\n              inputActionText = 'Create';\n              break;\n              \n            case 'delete':\n              inputMessage = 'Delete? ' + data.path;\n              defaultInput = null;\n              inputActionText = 'Delete';\n              break;\n              \n            default:\n            console.error('Invalid handleRightClickFs cmd:', data.cmd);\n              return false;\n              break;\n              \n          }\n           \n          this.setState({\n            showInput: true,\n            inputMessage,\n            inputCmd: data.cmd,\n            inputOriginalPath: data.path,\n            inputPath: defaultInput,\n            inputActionText\n          })\n          \n          if(this.inputPathRef){\n            this.inputPathRef.focus();\n          }\n          \n        }\n        \n        @autobind\n        async handlePathSubmit(){\n          // take the action specified in inputCmd \n          let {\n            inputMessage,\n            inputCmd,\n            inputOriginalPath,\n            inputPath // input via textbox \n          } = this.state;\n          \n          inputPath = inputPath ? inputPath.trim():inputPath;\n          if(typeof inputPath == 'string' && inputPath.substring(0,1) != '/'){\n            inputPath = '/' + inputPath;\n          }\n          \n          // collect input \n          // setup node input for request \n          // make request \n          // refresh files in related directories (or simply \"all\") \n        \n          if(inputPath == inputOriginalPath){\n            console.log('same path');\n            WINDOW.alert('Same path');\n            return false;\n          }\n          \n          let apiUrl = '/api/fs/' ;\n          let fsOpts = {}\n          switch(inputCmd){\n            case 'rename':\n              apiUrl += 'rename/';\n              apiUrl += this.props.state.editingNode.name + inputOriginalPath\n              fsOpts = {\n                to: inputPath\n              }\n              break;\n              \n            case 'move':\n              apiUrl += 'move/';\n              apiUrl += this.props.state.editingNode.name + inputOriginalPath\n              fsOpts = {\n                to: inputPath\n              }\n              break;\n              \n            case 'copy':\n              apiUrl += 'copy/';\n              apiUrl += this.props.state.editingNode.name + inputOriginalPath\n              fsOpts = {\n                to: inputPath\n              }\n              break;\n              \n            case 'delete':\n              apiUrl += 'remove/';\n              apiUrl += this.props.state.editingNode.name + inputOriginalPath\n              fsOpts = {}\n              break;\n              \n            case 'new-dir':\n              apiUrl += 'ensureDir/';\n              if(inputPath.substring(inputPath.length - 1) != '/'){\n                inputPath = inputPath + '/';\n              }\n              apiUrl += this.props.state.editingNode.name + inputPath\n              fsOpts = {\n                // prevent overwrite? \n              }\n              break;\n              \n            case 'new-file':\n              apiUrl += 'putText/';\n              apiUrl += this.props.state.editingNode.name + inputPath\n              fsOpts = {\n                text: ''\n              }\n              break;\n              \n            default:\n            console.error('Invalid handleRightClickFs cmd:', data.cmd);\n              return false;\n              break;\n              \n          }\n          \n          \n          let fsResult = await this.runFsCommand(apiUrl, fsOpts);\n          console.log('fsResult:', fsResult);\n          \n          this.setState({\n            showInput: false\n          });\n          \n          universe.EE.emit('files-modified',{});\n          \n        }\n        \n        @autobind\n        async runFsCommand(fetchUrl, opts){\n          \n          let result = await universe.fetch(fetchUrl,{\n            method: 'POST',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              type: 'types.second.default.fs_api',\n              data: {\n                // PATH: `${this.props.state.editingNode.name}${this.props.state.editingFilePath}`,\n                // cmd: 'putText',\n                opts\n              }\n            })\n          });\n          \n          let jresult = await result.json();\n          \n          return jresult;\n          \n        }\n        \n        @autobind\n        async handlePathCancel(){\n          this.setState({\n            showInput: false\n          })\n        }\n        \n        @autobind\n        renderTree(renderPath, parentInFilter, depth){\n          depth = depth || 0;\n          let filters = this.state.text.split('>');\n          // reverse filters when checking\n          filters.reverse();\n          \n          const isChildOf = (child, parent) => {\n            if (child === parent) return false\n            const childNoSlash = child.substring(child.length - 1) == '/' ? child.substring(0,child.length - 1):child;\n            // console.log('childNoSlash:', childNoSlash, parent, parent.indexOf(childNoSlash) === 0, parent.split('/').length == childNoSlash.split('/').length);\n            return childNoSlash.indexOf(parent) === 0 && parent.split('/').length == childNoSlash.split('/').length;\n          }\n\n          let paths = Object.keys(this.props.state.allPaths || {}).filter(p=>{\n            return isChildOf(p, renderPath);\n          });\n          // console.log('Nodes',nodes);\n          \n          if(!paths.length){\n            // console.log('No paths at path:', renderPath);\n            return '';\n          }\n          \n          // console.log('path matches:', renderPath, paths);\n          \n          return (\n            <div className=\"\">\n              {\n                paths.map(ap=>{\n                  \n                  let fPath = this.props.state.allPaths[ap];\n                  \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                  \n                  let showChildren = true;\n                  if(this.state.expandedPaths[ap]){\n                    showChildren = false;\n                  }\n                  \n                  let rowStyle = {whiteSpace:'nowrap'};\n                  if(this.props.state.editingFilePath && this.props.state.editingFilePath == ap){\n                    rowStyle.fontWeight = 'bold';\n                  }\n                  \n                  if(this.props.state.selectedPaths && this.props.state.selectedPaths.find(n=>{return n.name == ap})){\n                    rowStyle.background = 'red';\n                  }\n                  \n                  let fName = ap.substring(renderPath.length).split('/')[0];\n                  // console.log('fName:', fName, ap, renderPath);\n                  \n                  const {\n                    ContextMenuTrigger,\n                    ContextMenu,\n                    MenuItem\n                  }= universe.ReactContextMenu;\n                  \n                  let ext = fName.split('.').pop().toLowerCase();\n                  return (\n                    <div key={ap}>\n                      <ContextMenuTrigger id={ap}>\n                        <div style={{cursor:'pointer'}}>\n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              <span style={rowStyle}>\n                                {\n                                  (fPath.isDir) ?\n                                    <span onClick={e=>{this.handleClickFileOrDirectory(fPath, e);e.preventDefault();return false;}} style={{width:'22px',display:'inline-block'}}>{this.state.expandedPaths[ap] ? \n                                        <span className=\"icon is-small\">\n                                          <i className=\"far fa-folder\"></i>\n                                        </span>\n                                      :\n                                        <span className=\"icon is-small\">\n                                          <i className=\"fas fa-folder\"></i>\n                                        </span>}</span>\n                                  :<span style={{width:'22px',display:'inline-block'}}>\n                                    <span className=\"icon is-small\">\n                                      <i className={\"far \" + (extensions[ext] || icons.file)}></i>\n                                    </span>\n                                  </span>\n                                }\n                                <span onClick={e=>this.handleClickFileOrDirectory(fPath, e)} >{fName}</span>\n                              </span>\n                            </div>\n                          </div>\n                        </div>\n                      </ContextMenuTrigger>\n                      \n                      <ContextMenu id={ap}>\n                        <MenuItem data={{cmd: 'rename', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          Rename\n                        </MenuItem>\n                        <MenuItem data={{cmd: 'move', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          Move\n                        </MenuItem>\n                        <MenuItem data={{cmd: 'copy', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          Copy\n                        </MenuItem>\n                        <MenuItem data={{cmd: 'delete', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          Delete\n                        </MenuItem>\n                        <MenuItem divider />\n                        <MenuItem data={{cmd: 'new-dir', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          New Directory\n                        </MenuItem>\n                        <MenuItem data={{cmd: 'new-file', path: fPath.path}} onClick={this.handleRightClickFs}>\n                          New File\n                        </MenuItem>\n                      </ContextMenu>\n\n                      {\n                        (!fPath.isDir || !this.state.expandedPaths[ap] ) ? '':\n                        <div style={{paddingLeft:'22px'}}>\n                          {this.renderTree(ap, '', depth+1)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        @autobind\n        toggleHide(name){\n          let hiding = this.state.hiding;\n          if(hiding[name]){\n            hiding[name] = false;\n          } else {\n            hiding[name] = true;\n          }\n          console.log('Hiding:', hiding);\n          this.setState({hiding});\n        }\n        \n        @autobind\n        async handleSelectedFiles(event){\n          \n          // this.setState({files: event.target.value});\n          \n          console.log('event files:', event.target.files, event.target);\n          let files = await getFiles(event.target.files);\n          console.log('FILES:', files);\n          \n          if(!this.props.state.editingFilePath){\n            WINDOW.alert('Choose a parent directory to upload files to');\n            \n            // reset input\n            this.setState({\n              files: ''\n            });\n            return false;\n          }\n          \n          let parentDirectory = this.props.state.editingFilePath.name;\n          \n          parentDirectory = WINDOW.prompt('Parent directory for file upload', parentDirectory);\n          if(!parentDirectory){\n            // reset input\n            this.setState({\n              files: ''\n            });\n            return false;\n          }\n          \n          this.setState({\n            isUploading: true\n          });\n          \n          for(let file of files){\n            \n            // let file = files[idx];\n            // console.log('file:', file); //, idx);\n            // Upload each file to a new path \n            // - TODO: findAndUpdateOrCreate \n            \n            // Search remote nodes \n            // - services: create_if_cant_find\n            \n            let parentRegexp = '^' + parentDirectory.split('.').join('\\\\.') + '\\\\.[-\\\\w]+$';\n            \n            let response = await universe.$.ajax({\n              url: '/api/put_via_find_and_update_or_create',\n              method: 'post',\n              contentType: 'application/json',\n              data: JSON.stringify({\n                type: 'types.second.default.api_put_via_find_and_update_or_create',\n                data: {\n                  where: {\n                    name: {\n                      $regexp: parentRegexp //'^app\\\\.second\\\\.sample_pwa\\\\.static\\\\.[-\\\\w]+$', // so many damn slashes\n                    },\n                    'data.filename': file.name\n                  },\n                  put: {\n                    name: [parentDirectory, universe.uuidv4()].join('.'), // ignored if found above! \n                    type: 'types.second.default.static_file',\n                    data: {\n                      filename: file.name,\n                      mimetype: file.type,\n                      encoded: 'base64',\n                      base64: file.base64StringFile\n                    }\n                  }, // name is ignored!!\n                  opts: {\n                    multiple: false\n                  }\n                }\n              })\n            });\n            \n            console.log('response', response);\n            \n          }\n          \n          this.setState({\n            files: '',\n            isUploading: false\n          });\n  \n        }\n        \n        render(){\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\" style={{position:'relative'}}>\n              \n              <div style={{position:'sticky', top: '0px', borderBottom:'1px solid #ccc', background: '#eee', zIndex:'1', width:'100%'}}>\n                \n                {\n                  !this.state.pastable ? '':\n                  <div>\n                    <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                    <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                    <button className=\"button is-pulled-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                  </div>\n                }\n                \n                <strong>\n                  Files\n                  \n                  &nbsp;\n                  \n                  {/*\n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteFiles}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  */}\n                  \n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteFiles}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  \n                  <button className={\"button is-small \" + (this.state.isUploading ? 'is-loading':'')} onClick={this.handleUploadFile}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-upload \"></i>\n                    </span>\n                    <input type=\"file\" name=\"\" id=\"\" onChange={this.handleSelectedFiles} value={this.state.files} style={uploadInputStyle} multiple />\n                  </button>\n                  \n                  <button className={\"button is-small\"} onClick={e=>{this.handleRightClickFs(e,{path: 'example.txt' , cmd: 'new-file'})}}>\n                    +File\n                  </button>\n                  <button className={\"button is-small\"} onClick={e=>{this.handleRightClickFs(e,{path: '/' , cmd: 'new-dir'})}}>\n                    +Dir\n                  </button>\n                  \n                  \n                  \n                  \n                  <div className=\"dropdown is-hoverable is-right is-pulled-right\">\n                    <div className=\"dropdown-trigger\">\n                      <button className=\"button is-small\">\n                        <span className=\"icon is-small\">\n                          <i className=\"fa fa-angle-down\"></i>\n                        </span>\n                      </button>\n                    </div>\n                    <div className=\"dropdown-menu\">\n                      <div className=\"dropdown-content\">\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleNewId}>\n                          Copy New UUID to Clipboard\n                        </a>\n                        \n                        {/*\n                        <a className=\"dropdown-item\" onClick={this.handleNewFile}>\n                          New Node (path, type)\n                        </a>\n                        \n                          (this.props.state.selectedPaths && this.props.state.selectedPaths.length) ?\n                          <a className=\"dropdown-item\" onClick={this.handleDelete}>\n                            Delete Selected\n                          </a>:''\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleCreateInvite}>\n                          Create Invite\n                        </a>\n                        \n                        \n                        <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                          Insert Node By Paste\n                        </a>\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                          Import Bundle (.Zip, or GitHub) \n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                          Encrypt String\n                        </a>\n                        \n                        \n                        <div className=\"dropdown-divider\"></div>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                          Insert Many for Test\n                        </a>\n                        \n                        */}\n                        \n                      </div>\n                    </div>\n                  </div>\n                  \n                </strong>\n                \n                {/*\n                <div className=\"field has-addons\">\n                  <div className=\"control is-expanded\">\n                    <input \n                      className=\"input\" \n                      value={this.state.text} \n                      onChange={e=>this.setState({text:e.target.value})} \n                      placeholder=\"path e.g. types.standard\" \n                    />\n                  </div>\n                  <div className=\"control\">\n                    <input \n                      type=\"checkbox\"\n                      title=\"Show Children\"\n                      className=\"checkbox\" \n                      checked={this.state.showChildren} \n                      onChange={e=>this.setState({showChildren: !this.state.showChildren})} \n                      style={{width:'40px'}}\n                    />\n                  </div>\n                </div>\n                */}\n                \n              </div>\n              \n              <div style={{position:'relative'}}>\n              \n                  {\n                    !this.state.invalidRoot ? '':\n                    <button className={\"button is-small is-warning\"} onClick={this.handleEnsureRoot} title=\"Root folder not created for node\">\n                      Create Root for Node \n                    </button>\n                  }\n                  \n                {this.renderTree('/')}\n              </div>\n              \n              {\n                !this.state.showInput ? '':\n                <div id=\"file-input-path\" style={fileCmdInputStyle}>\n                  <div>\n                    {this.state.inputMessage}\n                  </div>\n                  <br />\n                  <div className=\"field has-addons\">\n                    {\n                      this.state.inputPath === null ? '':\n                      <div className=\"control is-expanded\">\n                        <input \n                          ref={(input) => { this.inputPathRef = input }} \n                          autoFocus\n                          className=\"input\" \n                          value={this.state.inputPath} \n                          onChange={e=>this.setState({inputPath:e.target.value})} \n                          onKeyDown={e=>{if(e.keyCode == 13){this.handlePathSubmit()}}}\n                          placeholder=\"\" \n                        />\n                      </div>\n                    }\n                    <div className=\"control\">\n                      <button className=\"button is-info\" onClick={this.handlePathSubmit}>{this.state.inputActionText}</button>\n                    </div>\n                    <div className=\"control\">\n                      <button className=\"button is-danger\" onClick={this.handlePathCancel}>Cancel</button>\n                    </div>\n                  </div>\n                </div>\n              }\n              \n            </div>\n          )\n        }\n      }\n      \n      let uploadInputStyle = {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        opacity: '0.00001'\n      }\n      \n      let fileCmdInputStyle = {\n        position: 'fixed',\n        bottom: 0,\n        left: 0,\n        width: '450px',\n        background: 'white',\n        padding: '14px 8px'\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n    const icons = {\n      image: 'fa-file-image',\n      pdf: 'fa-file-pdf',\n      word: 'fa-file-word',\n      powerpoint: 'fa-file-powerpoint',\n      excel: 'fa-file-excel',\n      audio: 'fa-file-audio',\n      video: 'fa-file-video',\n      zip: 'fa-file-archive',\n      code: 'fa-file-code',\n      text: 'fa-file-alt',\n      file: 'fa-file'\n    }\n  \n    const extensions = {\n      gif: icons.image,\n      jpeg: icons.image,\n      jpg: icons.image,\n      png: icons.image,\n  \n      pdf: icons.pdf,\n  \n      doc: icons.word,\n      docx: icons.word,\n  \n      ppt: icons.powerpoint,\n      pptx: icons.powerpoint,\n  \n      xls: icons.excel,\n      xlsx: icons.excel,\n  \n      aac: icons.audio,\n      mp3: icons.audio,\n      ogg: icons.audio,\n  \n      avi: icons.video,\n      flv: icons.video,\n      mkv: icons.video,\n      mp4: icons.video,\n  \n      gz: icons.zip,\n      zip: icons.zip,\n  \n      css: icons.code,\n      html: icons.code,\n      js: icons.code,\n  \n      txt: icons.text,\n  \n      file: icons.file\n    }\n    \n  })\n})()",
    "note": "/dev left side"
  },
  "blobdata": null,
  "createdAt": "2019-03-21T00:02:46.187Z",
  "updatedAt": "2019-03-21T00:02:46.187Z",
  "nodes": []
}