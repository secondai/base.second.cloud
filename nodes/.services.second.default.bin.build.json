{
  "name": "base.second.cloud.services.second.default.bin.build",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--API binary tool: install --', SELF.name);\n      \n      const util = universe.require('util');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n        \n      // INPUT\n      // type: types.second.default.bin.install.build \n      // data: {\n      //   nodePath,\n      //   target, // default: self\n      //   opts\n      // }\n      \n      // TODO: for errors, universe.isError() quick-checker against registered error types \n      \n        \n      let allowedBuildTypes = [\n        'types.second.default.app',\n        'types.second.default.code.js',\n        'types.second.default.service.js',\n        'types.second.default.permissions'\n      ];\n      \n      let {\n        nodePath,\n        target, // self, other\n        opts\n      } = INPUT.data;\n      \n      target = target || 'self'; \n      opts = opts || {};\n      opts = universe.lodash.defaults({},opts,{\n        imageOrCode: 'all'\n      });\n      \n      console.log('Build Opts.imageOrCode:', opts.imageOrCode);\n      \n      // Find appNode \n      node = await universe.getNodeAtPath(nodePath);\n      if(!node){\n        console.error('Missing node for build');\n        return resolve({\n          error: true,\n          message: 'Missing Node'\n        });\n      }\n      \n      if(allowedBuildTypes.indexOf(node.type) === -1){\n        console.error('Invalid type for build');\n        return resolve({\n          error: true,\n          message: 'Invalid type of node'\n        });\n      }\n      \n      // Check for \"self\" or other \n      if(!node.data.src[target]){\n        console.error('Missing target for build');\n        return resolve({\n          error: true,\n          message: 'Missing target'\n        });\n      }\n      \n      // Check for valid build parameters \n      if(!node.data.src[target].build){\n        console.error('Missing target.build for build');\n        return resolve({\n          error: true,\n          message: 'Missing target.build'\n        });\n      }\n      \n      var subDirectory = node.data.src[target].src.targetDir || '/';\n      \n      // what about sub-directories? \n      var DBUILDER_NAME = node.data.src[target].build.image || 'dbuilder_' + Date.now();\n      var DBUILDER_CONTEXT = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory); // path for dockerfile? \n      var DBUILDER_DOCKERFILE = node.data.src[target].build.dockerfile; //'dockerfile.second';\n      var DBUILDER_WORKDIR = DBUILDER_CONTEXT; \n      \n      var DBUILDER_DOCKERFILE_PATH = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory, DBUILDER_DOCKERFILE);\n      \n      // Run commands \n      // - Build image using dockerfile (and tag for use in a moment) \n      // - Build app by running special command: \"npm run second:build:self\" \n      // - retain image, or delete it? \n      //   - if dockerfile changes, then change, or provide additional options/apis? \n      \n      // docker run --volumes-from nodejs app_dbuilder:latest /bin/bash -c \\\"cd /usr/src/attached-volume/app.second.sample_pwa && yarn && npm run second:build:${target}\\\"\n      \n      let optsAllowImage, optsAllowCode, optsAllowDependencies;\n      switch(opts.imageOrCode){\n        case 'image-only':\n          optsAllowImage = true;\n          break;\n        case 'code-only':\n          optsAllowCode = true;\n          break;\n        case 'dependencies-only':\n          optsAllowDependencies = true;\n          break;\n        case 'all':\n          optsAllowImage = true;\n          optsAllowCode = true;\n          optsAllowDependencies = true;\n          break;\n        default:\n          console.error('Missing imageOrCode:', opts.imageOrCode);\n          break;\n      }\n      \n      let consoleOutput = [];\n      try {\n        \n        var command;\n        \n        // image already created? \n        if(optsAllowImage){\n          if(!node.data.src[target].build.image){\n            console.log('Building image:', DBUILDER_NAME);\n            command = `DBUILDER_NAME=${DBUILDER_NAME} DBUILDER_CONTEXT=${DBUILDER_CONTEXT} DBUILDER_DOCKERFILE=${DBUILDER_DOCKERFILE} docker-compose -f docker-compose.builder.yml build dbuilder`;\n            \n            console.log('Command:', command);\n            \n            var { stdout, stderr } = await exec(command);\n          \n            console.error('------------------------------');\n            console.error(`---exec error`, stderr);\n            console.error('------------------------------');\n            \n            console.log('------------------------------');\n            console.log(`---exec Run Output`, stdout);\n            console.log('------------------------------');\n            \n            consoleOutput.push({stderr});\n            consoleOutput.push({stdout});\n            // Update the node with the new Container name \n            // TODO\n            node.data.src[target].build.image = DBUILDER_NAME; // \"DBUILDER_NAME:latest\"\n            await universe.putNodeAtPath(nodePath, node);\n          } else {\n            console.error('Image already built');\n          }\n        }\n        \n        // Look for \"Successfully built\" in stdout\n        \n        // Install dependencies \n        // - this could be part of a different step? \n        // - Run node command to install packages (yarn) and build \n         if(optsAllowDependencies){\n          var DEPENDENCIES_COMMAND = node.data.src[target].build.dependenciesCommand || 'npm run second:dependencies:self';\n          console.log('Running npm command:', DEPENDENCIES_COMMAND);\n          command = `docker run --volumes-from nodejs ${DBUILDER_NAME} /bin/bash -c \"cd ${DBUILDER_CONTEXT} && ${DEPENDENCIES_COMMAND}\"`;\n          \n          var { stdout, stderr } = await exec(command);\n        \n          console.error('------------------------------');\n          console.error(`---exec error:`, stderr);\n          console.error('------------------------------');\n          \n          console.log('------------------------------');\n          console.log(`---exec Run Output:`, stdout);\n          console.log('------------------------------');\n          \n          consoleOutput.push({stderr});\n          consoleOutput.push({stdout});\n          \n         }\n         \n         \n         // Run webpack/etc \n         if(optsAllowCode){\n          var BUILD_COMMAND = node.data.src[target].build.command || 'npm run second:build:self';\n          console.log('Running npm command:', BUILD_COMMAND);\n          command = `docker run --volumes-from nodejs ${DBUILDER_NAME} /bin/bash -c \"cd ${DBUILDER_CONTEXT} && ${BUILD_COMMAND}\"`;\n          \n          var { stdout, stderr } = await exec(command);\n        \n          console.error('------------------------------');\n          console.error(`---exec error:`, stderr);\n          console.error('------------------------------');\n          \n          console.log('------------------------------');\n          console.log(`---exec Run Output:`, stdout);\n          console.log('------------------------------');\n          \n          consoleOutput.push({stderr});\n          consoleOutput.push({stdout});\n          \n          // Update with when it was last built \n          node.data.src[target].build.lastBuilt = new Date();\n          await universe.putNodeAtPath(nodePath, node);\n         }\n        \n      }catch(err){\n        console.error('Failed Command',err);\n        resolve({\n          error: true,\n          message: 'Failed',\n          err\n        });\n        return false;\n      }\n      \n      console.log('DONE');\n      resolve({\n        built: true,\n        error: false,\n        consoleOutput\n      })\n      return false;\n    \n      \n      return false;\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-16T02:18:31.746Z",
  "updatedAt": "2019-03-16T03:41:22.119Z",
  "nodes": []
}