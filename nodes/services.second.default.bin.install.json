{
  "name": "base.second.cloud.services.second.default.bin.install",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--API binary tool: install --', SELF.name);\n      \n      const util = universe.require('util');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n        \n      // INPUT\n      // type: types.second.default.bin.install.input \n      // data: {\n      //   nodePath,\n      //   target, // default: self\n      //   opts\n      // }\n      \n      // TODO: for errors, universe.isError() quick-checker against registered error types \n      \n        \n      let allowedBuildTypes = [\n        'types.second.default.app',\n        'types.second.default.code.js',\n        'types.second.default.service.js',\n        'types.second.default.permissions'\n      ];\n      \n      let {\n        nodePath,\n        target,\n        opts\n      } = INPUT.data;\n        \n      target = target || 'self'; \n      opts = opts || {};\n        \n      // INSTALL  \n      // - fetch .zip or repo\n      // - clear local directory \n      \n      // Find appNode \n      let node = await universe.getNodeAtPath(nodePath);\n      if(!node){\n        console.error('Missing node for install');\n        return resolve({\n          error: true,\n          message: 'Missing Node'\n        });\n      }\n      \n      if(allowedBuildTypes.indexOf(node.type) === -1){\n        console.error('Invalid type for install');\n        return resolve({\n          error: true,\n          message: 'Invalid type of node'\n        });\n      }\n      \n      // Check for \"self\" or other \n      if(!node.data.src[target]){\n        console.error('Missing target for install');\n        return resolve({\n          error: true,\n          message: 'Missing target'\n        });\n      }\n      \n      // RESPONDING IMMEDIATELY\n      universe.globalCache.installing = universe.globalCache.installing || {};\n      universe.globalCache.installing[nodePath] = universe.globalCache.installing[nodePath] || {\n        started: false,\n        error: null,\n        finished: false,\n        lastMessage: null\n      }\n      let installing = universe.globalCache.installing[nodePath];\n      if(installing.started){\n        if(installing.error){\n          // send error once \n          resolve({\n            error: 'Error in previous, now can run /install again',\n            message: installing.error,\n            lastMessage: installing.lastMessage\n          });\n          installing.started = true;\n          installing.error = false;\n          return;\n        } else {\n          // resolve({\n          //   installing: true,\n          //   started: installing.started,\n          //   message: installing.lastMessage\n          // });\n          // return;\n        }\n      } else {\n        if(installing.finished){\n          resolve(installing);\n          installing.finished = false;\n          return;\n        }\n      }\n      \n      \n      installing.started = Date.now();\n      installing.error = null;\n      installing.lastMessage = 'Starting';\n      resolve(installing);\n      \n      // console.log('Writing file:', finalVolumeLookupPath, path.dirname(finalVolumeLookupPath));\n      // mkdirp.sync(path.dirname(finalVolumeLookupPath));\n      // fs.writeFileSync(finalVolumeLookupPath, 'testingafile');\n      \n      var volumePrefix = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath);\n      \n      var targetDir = node.data.src[target].src.targetDir || '';\n      \n      var extractToPath = path.join(volumePrefix, targetDir);\n      \n      extractToPath = extractToPath.split('').pop() === '/' ? extractToPath : (extractToPath+'/');\n      \n      // let tmppath = universe.env.ATTACHED_VOLUME_ROOT + 'app.second.xyz2';//nodePath;\n      // mkdirp.sync(tmppath);\n      // let staticRootPath = volumePrefix + staticFileDirectory;\n      \n      // // clear directory (make optional?) \n      // // - shouldn't need to clear node_modules every time? \n      // fs.emptyDirSync(volumePrefix)\n      \n      var zipUrl = node.data.src[target].src.zipUrl;\n      \n      // fetch zip and extract to correct place \n      console.log('Extracting to:', extractToPath);\n      installing.lastMessage = 'Extracting';\n      let Writer = universe.require('fstream').Writer;\n      \n      // TODO: look for package.json and extract that level of files? \n      let removeFirstLevelDirectory = (zipUrl.indexOf('github') > -1 ) ? true:false; // necessary for importing zip from github \n      // request('https://github.com/secondai/second_template_pwa/archive/master.zip')\n      // request('https://repl.it/@nicholasareed/secondtemplatepwa.zip')\n      \n      try {\n        \n        // // fs.emptyDirSync(extractToPath);\n        // let toDelete = await del([volumePrefix + '/**'], {\n        //   dryRun: false, \n        //   force: true\n        // });\n        // console.log('toDelete', extractToPath + '**', toDelete);\n        \n        // try {\n        //   mkdirp.sync(extractToPath);\n        // }catch(err){\n        //   // console.error('Failed mkdirp (somehow):', err);\n        //   // return false;\n        // }\n      \n        await request(zipUrl)\n        .pipe(unzipper.Extract({ \n          path: path.resolve(extractToPath),\n          getWriter: (wr)=>{\n            // // rewrite paths to extract to SAME DIRECTORY \n            // // - fixes github zip, might break other sites \n            let newpath;\n            if(removeFirstLevelDirectory){\n              newpath = path.join(extractToPath, wr.path.substring(extractToPath.length).split('/').slice(1).join('/'));\n            } else {\n              newpath = wr.path;\n            }\n            console.log(wr.path, newpath); //path.substring(extractToPath.length));\n            // console.log('updated path', path);\n            return Writer({path: newpath})\n          }\n        }))\n        .promise();\n      }catch(err){\n        console.error('Failed extracting:', err);\n        installing.started = false;\n        installing.finished = true;\n        installing.error = err;\n        installing.lastMessage = 'Failed, error extracting';\n        return false;\n      }\n      \n      ////////////////////////////////////////////////////////////////////////\n      //////////////////////////////////////////////////////////////////////// EXITING HERE\n      ////////////////////////////////////////////////////////////////////////\n      installing.started = false;\n      installing.finished = true;\n      installing.error = null;\n      installing.lastMessage = 'Finished extracting to local, now run /build';\n      // resolve('extracted, NOT installed');\n      \n      return false;\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-16T02:18:31.665Z",
  "updatedAt": "2019-03-17T21:50:11.375Z",
  "nodes": []
}