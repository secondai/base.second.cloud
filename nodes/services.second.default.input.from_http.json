{
  "name": "base.second.cloud.services.second.default.input.from_http",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting an Expressjs object for input \n      // - types.second.default.request.http_express_obj\n      \n      // request via HTTP post method (expressjs server expected) \n      // - headers and body are included\n      //   - body is JSON (expected to be!) \n      \n      // console.log('incoming_web_request!!');\n      // return resolve({\n      //   ok: true\n      // });\n          \n      \n      let expressNode, headers, body, urlPath;\n      \n      switch(INPUT.type){\n        \n        case 'types.second.default.request.http_express_obj':\n          // Express HTTP Request (default) \n          \n          expressNode = INPUT; \n          \n          headers = expressNode.data.req.headers;\n          body = expressNode.data.req.body;\n          urlPath = expressNode.data.req.path;\n          \n          console.log('Incoming Route Request. INPUT.type:', INPUT.type, expressNode.data.req.originalUrl);\n          \n          break;\n          \n          \n        default:\n          console.error('Failed INPUT.type for from_http');\n          return resolve({\n            type: 'invalid_internal_type:Qmsdfisf',\n            data: false\n          });\n      }\n      \n      \n      // console.log('BODY:', JSON.stringify(body,null,2));\n      // console.log('ExpressNode:', universe.cJSON.stringify(expressNode,null,2));\n      \n      \n      // Load routes, controllers for each (TODO) \n      // - MVC-like for web requests, expecting most non-node requests to be authentication one-offs \n      \n      \n      // // cache the route-finding code \n      // let cacheAppId = universe.getParentRoot(SELF)._id;\n      // let cache = ['incoming_web_request_route_nodes', cacheAppId].join('|');\n      \n      // // app root-level (old: global-root) \n      // let routeNodes = await universe.searchMemory({\n      //   cache,\n      //   filter: {\n      //     sqlFilter: {\n      //       // nodeId: null // OLD: root-level\n      //       type: 'incoming_route_handler:Qmsdfkj329j3'\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n      //       return new Promise((resolve, reject)=>{\n      //         tmpNodes = tmpNodes.filter(tmpNode=>{\n      //           // see if has a ChildNode matching a type \n                \n      //           if(!universe.sameAppPlatform(SELF, tmpNode)){\n      //             // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n      //             return false;\n      //           }\n                \n      //           return true;\n                \n      //         });\n      //         resolve(tmpNodes);\n      //       });\n      //     },\n      //   }\n      // });\n      \n      // console.log('Getting routeNodes');\n      \n      let routeNodes = await universe.getNodesForPathPattern('data.second.default.routes.*',{});\n      \n      // console.log('routeNodes:', routeNodes.length);\n      // console.log('routeNodes length:', routeNodes.length);\n      \n      // console.log('Sort routes');\n      \n      // prevent \"/ai\" from being pushed to the bottom! \n      // - mucking with /ai will cause some serious problems! \n      \n      let routes = routeNodes.sort((a,b)=>{\n        try {\n            // multiple /ai's?\n          if((!a.data || !b.data) || (a.data.ai && !b.data.ai)){\n            return -1;\n          }\n          if(b.data.ai && !a.data.ai){\n            return 1;\n          }\n          return (a.data.priority > b.data.priority) ? 1:-1; // lower priority => checked first!\n        }catch(err){\n          console.error('err sorting routes:', err);\n          return 0;\n        }\n      }).map(routeNode=>{\n        // get codeNode to run \n        let routeTxtMatches = routeNode.data ? (routeNode.data.routes || []):[]; // multiple allowed \n        \n        let routeCodeNodeToRun = universe.lodash.find(routeNode.nodes,n=>{\n          return n.name.endsWith('.code');\n        });\n        \n        return [routeTxtMatches, routeCodeNodeToRun, routeNode];\n      });\n      \n      // console.log('Checking routes', routes.length);\n      \n      // // print out routes to check (order\n      // for(let route1 of routes){\n      //   console.log('ROUTECheck1:',JSON.stringify(route1[0]));\n      // }\n      \n      const RouteParser = universe.require('route-parser');\n      \n      let routed = false;\n      for(let route of routes){\n        if(routed){continue}\n        for(let tmpMatchRoute of route[0]){\n          if(routed){continue}\n          let tmpRoute = new RouteParser(tmpMatchRoute);\n          let match = tmpRoute.match(urlPath)\n          if(match){\n            routed = true;\n            \n            // console.log('MATCH ROUTE:', match ? true:false, tmpMatchRoute, match);\n            \n            // update expressNode with params\n            expressNode.data.params = match;\n            \n            // check authentication\n            // - as part of routeNode.data.auth (TODO: better auth/versioning/groups/etc) \n            let routeNode = route[2];\n            if(routeNode.data.auth){\n              // require loggedin? \n              // - all apps are internal-only? \n              // - TODO: per-app basis? \n              let {req,res} = expressNode.data;\n              if(req.session.loggedin){\n                if(routeNode.data.auth.loggedin !== true){\n                  // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                  res.redirect(`/auth/logout2?redirect=${encodeURIComponent(req.originalUrl)}`);\n                  return resolve(true);\n                }\n              } else {\n                // not logged in, anonymous must be allowed \n                if(routeNode.data.auth.anonymous !== true){\n                  // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                  res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n                  return resolve(true);\n                }\n              }\n              \n            }\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let routeResult;\n            try {\n              // console.log('Getting routeResult');\n              routeResult = await universe.execCodeNode({\n                codeNode: route[1], // includes type/schemaName and data \n                dataNode: expressNode, // passes express obj, with req, res \n                timeout: 15 * 1000\n              });\n            }catch(err){\n              return resolve('FAILED code from from_http, trying to run route');\n            }\n            \n            // console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n            return resolve({\n              type: 'executed_route:Qmmf3290jhgj',\n              data: true\n            });\n            \n          }\n        }\n      }\n      \n      if(!routed){\n        console.log('No Route Matches');\n        await universe.httpResponse('send','404 - Missing Page');\n        \n        return resolve({\n          type: 'missing_route:Qm404sfhsf',\n          data: false\n        });\n      }\n      \n      return resolve({\n        type: 'boolean:...',\n        data: true\n      });\n      \n      \n        \n        \n    }catch(err){\n      console.error('Failed route:', err);resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "description": "Default handler for an http input"
  },
  "blobdata": null,
  "createdAt": "2019-03-20T23:53:26.580Z",
  "updatedAt": "2019-03-20T23:53:26.580Z",
  "nodes": []
}