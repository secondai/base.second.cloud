{
  "type": "types.second.default.code.js",
  "name": "app.second.sample_pwa.http_request",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App: --', PATH);\n      \n      // handle incoming request for an app (view, api)  \n      // - expecting express_obj \n      \n      let htmlNode, page;\n      \n      // get request session object (for finding if logged in using a cookie) \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      // Manifest \n      if(req.originalUrl.indexOf('/manifest.json') > -1){\n        let manifestNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'manifest') );\n        return res.send(manifestNode ? manifestNode.data : null);\n      }\n      \n      // Service-worker (js) \n      if(req.originalUrl.indexOf('/service-worker.js') > -1){\n        let serviceWorkerNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'service-worker') );\n        if(!serviceWorkerNode){\n          return res.status(404).send('');\n        }\n        res.writeHead(201, {\n          'Content-Type': 'application/javascript'\n        });\n        res.end(serviceWorkerNode.data.script || '');\n        return;\n      }\n      \n      \n      \n      // TODO: Handle /view vs. /api requests \n      // - few standardized app endpoints: use /ai for discovery and recommendations \n      let urlPath = '/static';\n      let staticIdx = req.originalUrl.indexOf(urlPath);\n      if(staticIdx > -1){\n        // console.log('Returning static files');\n        let staticFilePath = req.originalUrl.substring(staticIdx + urlPath.length + 1);\n        // console.log('staticFilePath:',staticFilePath);\n        // console.log('FULL PATH:', universe.navPathv1(SELF.name, 1, 'static.' + staticFilePath));\n        \n        // TODO: stream to client\n        // - don't fetch-and-send \n        \n        // get the blob data \n        // - data comes out as a Buffer\n        // let blobBuffer = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'static.' + staticFilePath) );\n        // if(!blobBuffer){\n        //   // console.log('No data found for blobbuffer');\n        //   return res.status(404).send(null);\n        // }\n        const Op = universe.sharedServices.db.Sequelize.Op;\n        \n        // \"static\" is same level as http_request\n        let staticDirectorySearch = '^' + universe.navPathv1(SELF.name, 1, 'static').split('.').join('\\\\.') + '\\\\.[-\\\\w]+$';\n  \t\t  let blobBuffer = await universe.sharedServices.db.Node.find({\n  \t\t    where: {\n  \t\t      name: {\n  \t\t        [Op.regexp]: staticDirectorySearch\n  \t\t      },\n  \t\t      'data.filename': staticFilePath\n  \t\t    },\n  \t\t    // {\n  \t\t    //   name: {\n  \t\t    //     $regexp: '^app\\\\.second\\\\.sample_pwa\\\\.static\\\\.[-\\\\w]+$'\n  \t\t    //   }\n  \t\t    // }, \n  \t\t    raw: true,\n  \t\t    // operatorsAliases: { $regex: Op.regex } \n  \t\t  });\n        if(!blobBuffer){\n          // console.log('No data found for blobbuffer');\n          return res.status(404).send(null);\n        }\n        \n        // TODO: parse out the mime-type (if included) and use as the Content-Type (writeHead) \n        let dataBuffer = new Buffer(blobBuffer.data.base64, 'base64');\n        // console.log('Got dataBuffer as Buffer (from base64)');\n        if(blobBuffer.data.mimetype){\n          res.writeHead(200, {\n            'Content-Type': blobBuffer.data.mimetype,\n            'Content-Length': dataBuffer.length,\n            'Content-Disposition': 'inline'\n          });\n          res.end(dataBuffer);\n        } else {\n          res.send(dataBuffer);\n        }\n        return;\n        \n        // // return frontend code (all nodes)\n        // let frontendNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'frontend') );\n        // let frontendNodes = [];\n        // function toArray(node){\n        //   node.name = node.name.substr(frontendNode.name.length + 1);\n        //   frontendNodes.push(node);\n        //   if(node.nodes){\n        //     for(let node2 of node.nodes){\n        //       toArray(node2);\n        //     }\n        //     delete node.nodes; // cleanup\n        //   }\n        // }\n        // for(let node of frontendNode.nodes){\n        //   toArray(node);\n        // }\n        // await universe.httpResponse('send', frontendNodes); //page.replace(new RegExp(\"\\\\n\", 'g'), \"\\\\n\"));\n        \n        // return resolve(true);\n      }\n      \n      \n      htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'view_html'));\n      console.log('htmlNode:', htmlNode);\n      res.send(htmlNode.data.html);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      console.error(err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}