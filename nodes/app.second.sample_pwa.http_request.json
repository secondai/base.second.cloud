{
  "name": "base.second.cloud.app.second.sample_pwa.http_request",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App: --', SELF.name);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let appPath = universe.navPathv1(SELF.name, 1)\n      let appNode = await universe.getNodeAtPath(appPath);\n      \n      let usedPath = req.url.split('/').slice(0,3).join('/');\n      let appLookupPath = req.url.substring(usedPath.length);\n      \n      \n      // Capture /api and other routes \n      // Fallback to static file sending \n      \n      const RouteParser = universe.require('route-parser');\n      \n      // handle incoming request for an app (view, api)  \n      // - expecting express_obj \n      // - also handling authentication here (allow anonymous, etc.) for paths \n      \n      \n      // console.log('http_request sample_pwa INPUT:', INPUT.type, INPUT.data);\n      // INPUT = express_obj\n      \n      let htmlNode, page;\n      \n      // Load static files from appPath\n      // - no auth required \n      // - simple redirect? \n      if(!universe.env.ATTACHED_VOLUME_ROOT){\n        console.error('Missing ATTACHED_VOLUME_ROOT');\n        return res.status(404).send('Missing File');\n      }\n      let staticFileDirectory = appNode.data.frontendStaticFileDirectory || '';\n      let volumePrefix = universe.env.ATTACHED_VOLUME_ROOT + appPath;\n      let staticRootPath = volumePrefix + staticFileDirectory;\n      let volumeLookupPath = staticRootPath + appLookupPath;\n      let finalVolumeLookupPath = path.resolve(volumeLookupPath);\n      if(finalVolumeLookupPath.indexOf(volumePrefix + '/') !== 0){\n        console.error('Invalid PATH lookup!', finalVolumeLookupPath);\n        return res.status(404).send('Missing File');\n      }\n      let exists = fs.existsSync(finalVolumeLookupPath);\n      if(exists){\n        console.log('finalVolumeLookupPath:',finalVolumeLookupPath);\n        res.sendFile(finalVolumeLookupPath);\n        return resolve(true);\n      }\n      \n      // get url relative to myself \n      // let appPath = universe.navPathv1(SELF.name, 1)\n      console.log('appLookupPath:', appLookupPath, req.originalUrl, appPath);\n      \n      let routesWithAuth = [\n        {\n          routes: '/install',\n          directToCode: 'install',\n          anonymous: false,\n          loggedin: true\n        },\n        {\n          routes: '/edit',\n          directToCode: 'edit',\n          anonymous: false,\n          loggedin: true\n        },\n        {\n          routes: '/build',\n          directToCode: 'build',\n          anonymous: false,\n          loggedin: true\n        },\n        {\n          routes: '/sandbox',\n          directToCode: 'sandbox',\n          anonymous: false,\n          loggedin: true\n        },\n        {\n          routes: '/update',\n          directToCode: 'update',\n          anonymous: false,\n          loggedin: true\n        },\n        \n        {\n          routes: [\n            '/api/*apirouteinfo',\n          ],\n          anonymous: true,\n          loggedin: true\n        },\n        {\n          routes: 'all',\n          anonymous: true,\n          loggedin: true\n        }\n      ]\n      \n      let allow = false;\n      let routed = false;\n      let returnedAlready = true;\n      for(let routeAuth of routesWithAuth){\n        if(routed){continue}\n        let routes = universe.lodash.isArray(routeAuth.routes) ? routeAuth.routes:[routeAuth.routes];\n        for(let tmpMatchRoute of routes){\n          if(routed){continue}\n          if(typeof tmpMatchRoute != 'string'){continue}\n          // TODO: test for invalid \"/*\" type of routes (MUST HAVE THE VAR NAME AFTER \"*\" LIKE \"/*all\") \n          // - somehow \"/*\" is ok but \"/static/*\" isnt, which is frustrating \n          let tmpRoute = new RouteParser(tmpMatchRoute);\n          let match = tmpRoute.match(appLookupPath)\n          if(match || routes == 'all'){\n            routed = true;\n            console.log('http_request (inside) App Route Match:', appLookupPath, tmpMatchRoute);\n            \n            // check authentication\n            // - as part of routeAuth (TODO: better auth/versioning/groups/etc) \n          \n            // require loggedin? \n            // - all apps are internal-only? \n            // - TODO: per-app basis? \n            if(req.session.loggedin){\n              if(routeAuth.loggedin !== true){\n                // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                res.redirect(`/auth/relogin?redirect=${encodeURIComponent(req.originalUrl)}`);\n                return resolve(true);\n              }\n            } else {\n              // not logged in, anonymous must be allowed \n              if(routeAuth.anonymous !== true){\n                // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                console.info('Not Logged in, Not allowing anonymous (redirecting)');\n                res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n                return resolve(true);\n              }\n            }\n            \n            allow = true;\n            \n            if(routeAuth.directToCode){\n              returnedAlready = false;\n              // if(routeAuth.directReturnImmediate){\n              //   res.send('Running Command: ' + routeAuth.directToCode);\n              // }\n              let codeResult;\n              try {\n                console.log('Running direct:', routeAuth.directToCode);\n                let directCodeNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, routeAuth.directToCode) );\n                if(!directCodeNode){\n                  console.error('Missing direct code node for path match obj:', routeAuth, SELF.name);\n                  return;\n                }\n                codeResult = await universe.execCodeNode({\n                  codeNode: directCodeNode,\n                  dataNode: INPUT, // passes incoming express obj, with req, res \n                });\n                console.log('Output from routeAuth.directToCode:', codeResult);\n                return; \n              }catch(err){\n                universe.scriptError(err, SELF);\n                return resolve('FAILED directCodeNode');\n              }\n              \n            }\n            \n          }\n        }\n      }\n      if(returnedAlready){\n        return resolve(true);\n      }\n      if(!allow){\n        console.log('404 for a user:', appLookupPath);\n        return res.status(404).send(404);\n      }\n      \n      // direct paths to relative code node \n      \n      if(appLookupPath == '/clear'){\n        console.error('----CLEARING----', volumePrefix);\n        fs.emptyDirSync(volumePrefix)\n        return res.send('Clearing app, please wait: ' + volumePrefix);\n      }\n      \n      // TODO: possible /api endpoints \n      \n      // TODO: 404 if was looking for a file? http status code for \"client-side routing?\" \n      // - instead of returning the index each time?\n      // - how do we *know* it was a file request? \n      \n      console.error('Returning default index.html');\n      let defaultIndexFullPath = staticRootPath + '/index.html';\n      let indexExists = fs.existsSync(defaultIndexFullPath);\n      if(indexExists){\n        console.log('Returning index.html for path:', req.originalUrl);\n        res.send('index');\n        // res.sendFile(defaultIndexFullPath);\n      } else {\n        console.error('App not installed:', defaultIndexFullPath);\n        res.status(404).send('App not installed');\n      }\n      \n      // // clear directory \n      // fs.emptyDirSync(volumePrefix)\n      \n      // console.log('Extracting');\n      // let Writer = universe.require('fstream').Writer;\n      // let removeFirstLevelDirectory = false; // necessary for importing zip from github \n      // // request('https://github.com/secondai/second_template_pwa/archive/master.zip')\n      // request('https://repl.it/@nicholasareed/secondtemplatepwa.zip')\n      // .pipe(unzipper.Extract({ \n      //   path: path.resolve(volumePrefix),\n      //   getWriter: ({path})=>{\n      //     // rewrite paths to extract to SAME DIRECTORY \n      //     // - fixes github zip, might break other sites \n      //     if(removeFirstLevelDirectory){\n      //       path = volumePrefix + '/' + path.substring(volumePrefix.length).split('/').slice(2).join('/');\n      //     }\n      //     console.log('updated path', path);\n      //     return Writer({path})\n      //   }\n      // }));\n      \n      \n      \n      // var lookupUrl = appNode.data.staticUrlProxy + lookupPath;\n      // console.log('Final URL:', lookupUrl);\n      // req.pipe(universe.webrequest(lookupUrl)).pipe(res);\n      return resolve(true);\n      \n      \n      \n      \n      // // TODO: Handle /view vs. /api requests \n      // // - few standardized app endpoints: use /ai for discovery and recommendations \n      // let staticUrlPath = '/static';\n      // let staticIdx = req.originalUrl.indexOf(staticUrlPath);\n      // if(staticIdx > -1){\n      //   // console.log('Returning static files');\n      //   let staticFilePath = req.originalUrl.substring(staticIdx + staticUrlPath.length + 1);\n      //   // console.log('staticFilePath:',staticFilePath);\n      //   // console.log('FULL PATH:', universe.navPathv1(SELF.name, 1, 'static.' + staticFilePath));\n        \n      //   // TODO: stream to client\n      //   // - don't fetch-and-send \n        \n      //   // get the blob data \n      //   // - data comes out as a Buffer\n      //   // let blobBuffer = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'static.' + staticFilePath) );\n      //   // if(!blobBuffer){\n      //   //   // console.log('No data found for blobbuffer');\n      //   //   return res.status(404).send(null);\n      //   // }\n      //   const Op = universe.sharedServices.db.Sequelize.Op;\n        \n      //   // \"static\" is same level as http_request\n      //   let staticDirectorySearch = '^' + universe.navPathv1(SELF.name, 1, 'static').split('.').join('\\\\.') + '\\\\.[-\\\\w]+$';\n  \t\t  // let blobBuffer = await universe.sharedServices.db.Node.find({\n  \t\t  //   where: {\n  \t\t  //     name: {\n  \t\t  //       [Op.regexp]: staticDirectorySearch\n  \t\t  //     },\n  \t\t  //     'data.filename': staticFilePath\n  \t\t  //   },\n  \t\t  //   // {\n  \t\t  //   //   name: {\n  \t\t  //   //     $regexp: '^app\\\\.second\\\\.sample_pwa\\\\.static\\\\.[-\\\\w]+$'\n  \t\t  //   //   }\n  \t\t  //   // }, \n  \t\t  //   raw: true,\n  \t\t  //   // operatorsAliases: { $regex: Op.regex } \n  \t\t  // });\n      //   if(!blobBuffer){\n      //     console.log('No data found for blobbuffer for FILE:', staticFilePath);\n      //     return res.status(404).send(null);\n      //   }\n        \n      //   // TODO: parse out the mime-type (if included) and use as the Content-Type (writeHead) \n      //   let dataBuffer = new Buffer(blobBuffer.data.base64, 'base64');\n      //   // console.log('Got dataBuffer as Buffer (from base64)');\n      //   if(blobBuffer.data.mimetype){\n      //     res.writeHead(200, {\n      //       'Content-Type': blobBuffer.data.mimetype,\n      //       'Content-Length': dataBuffer.length,\n      //       'Content-Disposition': 'inline'\n      //     });\n      //     res.end(dataBuffer);\n      //   } else {\n      //     res.send(dataBuffer);\n      //   }\n      //   return;\n        \n      //   // // return frontend code (all nodes)\n      //   // let frontendNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'frontend') );\n      //   // let frontendNodes = [];\n      //   // function toArray(node){\n      //   //   node.name = node.name.substr(frontendNode.name.length + 1);\n      //   //   frontendNodes.push(node);\n      //   //   if(node.nodes){\n      //   //     for(let node2 of node.nodes){\n      //   //       toArray(node2);\n      //   //     }\n      //   //     delete node.nodes; // cleanup\n      //   //   }\n      //   // }\n      //   // for(let node of frontendNode.nodes){\n      //   //   toArray(node);\n      //   // }\n      //   // await universe.httpResponse('send', frontendNodes); //page.replace(new RegExp(\"\\\\n\", 'g'), \"\\\\n\"));\n        \n      //   // return resolve(true);\n      // }\n      \n      \n      // htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'view_html'));\n      // console.log('htmlNode:', htmlNode);\n      // res.send(htmlNode.data.html);\n      \n      // return resolve(true);\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-16T02:16:29.382Z",
  "updatedAt": "2019-03-16T09:39:45.990Z",
  "nodes": []
}