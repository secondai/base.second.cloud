{
  "name": "base.second.cloud.data.second.default.routes.api_put_via_find_and_update_or_create.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: --', SELF.name);\n      \n      // This is just temporary! \n      let {\n        req,\n        res\n      } = INPUT.data;\n      \n      let bodyNode = req.body;\n      let opts = bodyNode.data.opts || {};\n      \n      console.log('bodyNode:', bodyNode);\n      \n      if(bodyNode.type != 'types.second.default.api_put_via_find_and_update_or_create'){\n        console.error('Invalid type of input req.body');\n        res.send({type:'types.second.default.error',message: 'Invalid type of input req.body (expected \"api_put_via_find_and_update_or_create\" got \"'+bodyNode.type+'\"'});\n        return reject(false);\n      }\n      \n\t\t  const Op = universe.sharedServices.db.Sequelize.Op;\n\t\t  \n\t\t  // // Fix 'where' to include regex on name (Sequelize Operator Aliases, should be disabled by default)\n\t\t  // function updateKeys(obj) {\n    //     for(var key in obj) {\n    //       if(key == '$regex'){\n    //       } else if(typeof obj[key] === \"object\") {\n    //         var subkeys = updateKeys(obj[key]);\n    //         keys = keys.concat(subkeys.map(function(subkey) {\n    //           return key + \".\" + subkey;\n    //         }));\n    //       }\n    //     }\n    //   }\n\t\t  \n\t\t  let nodes = await universe.sharedServices.db.Node.findAll({\n\t\t    where: bodyNode.data.where,\n\t\t    // {\n\t\t    //   name: {\n\t\t    //     $regexp: '^app\\\\.second\\\\.sample_pwa\\\\.static\\\\.[-\\\\w]+$'\n\t\t    //   }\n\t\t    // }, \n\t\t    raw: true,\n\t\t    // operatorsAliases: { $regex: Op.regex } \n\t\t  });\n\t\t  \n\t\t  // Expecting only (at most) 1 to be returned \n\t\t  // - create if not exists \n\t\t  //- TODO: transactions \n\t\t  if(nodes.length > 1 && !opts.multiple){\n\t\t    // invalid multiple attempted \n        console.error('Invalid multiple put attempt. Length:', nodes.length);\n        res.send({type:'types.second.default.error',message: 'Invalid multiple put attempt'});\n        return reject(false);\n\t\t  }\n\t\t  \n\t\t  // found at all? \n\t\t  if(nodes.length){\n\t\t    // 1 or multiple to update, IGNORE the 'name' part of the put \n\t\t    console.log('Updating one/many:-------', nodes.length, '--------', nodes.map(n=>n.name));\n  \t\t  let updatedNodes = await universe.sharedServices.db.Node.update({\n  \t\t    type: bodyNode.data.put.type,\n  \t\t    data: bodyNode.data.put.data,\n  \t\t  },{\n  \t\t    where: bodyNode.data.where,\n  \t\t    raw: true\n  \t\t  });\n  \t\t  console.log('Updated multiple', updatedNodes);\n\t\t  } else {\n\t\t    // create, none existed before\n\t\t    // - name MUST be included, else uh-oh \n\t\t    if(!bodyNode.data.put.hasOwnProperty('name') || !bodyNode.data.put.name.length){\n\t\t      throw \"Name was missing\"\n\t\t    }\n\t\t    console.log('Creating, none previously existed', bodyNode.data.put.name);\n\t\t    let putOpts = {};\n  \t\t  let newNode = await universe.putNodeAtPath(bodyNode.data.put.name, bodyNode.data.put, null, putOpts);\n\t\t  }\n      \n      res.send('done');\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-05T22:38:12.925Z",
  "updatedAt": "2019-03-17T21:50:37.637Z",
  "nodes": []
}