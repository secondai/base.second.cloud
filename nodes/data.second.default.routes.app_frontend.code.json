{
  "name": "base.second.cloud.data.second.default.routes.app_frontend.code",
  "type": "types.second.default.code.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App route handler--', SELF.name);\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      // console.log('INPUT for app:', INPUT);\n      let {\n        body,\n        path\n      } = req;\n      \n      // Logic: \n      // - find the possible apps we would load \n      //   - app.author.appname.* (eventually, search for \"first of type\" in a chain?) \n      // - get the input app name \n      //   - if exists, pass off the INPUT request \n      //   - if doesn't exist, show an Install page, with recommended sources for downloading the app to your Second (store, github, direct, etc)\n      //     - TODO: review the app source code easily, get a security/trust score \n      \n      console.log('PATH:', path);\n      \n      let appPath = path.split('/')[2]; // /app/appname/etc\n      \n      console.log('appath:', appPath); \n      if(appPath.indexOf('app.') !== 0){\n        // not a valid appPath \n        console.error('Not a valid appPath!:', appPath);\n        res.send('This is not a valid app path');\n        return resolve(false);\n      }\n      \n      let htmlNode;\n      \n      // require loggedin \n      // - all apps are internal-only? \n      // - TODO: per-app basis? \n      if(!req.session.loggedin){\n        // htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'login_required_html'));\n        // res.send(htmlNode ? htmlNode.data.html : 'Invalid Login Node');\n        console.log('login required, redirecting');\n        res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n        return resolve(true);\n      }\n      \n      // - find the app name \n      let appNode = await universe.getNodeAtPath(appPath);\n      if(!appNode){\n        console.error('Missing appNode');\n        htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'install_html'));\n        res.send(htmlNode ? htmlNode.data.html : 'Invalid Install Node');\n        return false;\n      }\n      if(appNode.type != 'types.second.default.app'){\n        // invalid type of appNode \n        console.error('Invalid type of appNode ');\n        res.send('Invalid internal app specified (1)');\n        return false;\n      }\n      \n      console.log('got appNode:',appNode);\n      \n      let codeNode = appNode.nodes.find(n=>{return n.name.split('.').pop() == 'request'});\n      if(!codeNode){\n        console.error('Invalid .request codeNode for appNode ');\n        res.send('Invalid internal app specified (2)');\n        return false;\n      }\n      \n      // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n      let appResult;\n      try {\n        // console.log('Getting appResult');\n        appResult = await universe.execCodeNode({\n          codeNode,\n          dataNode: INPUT, // passes express obj, with req, res \n        });\n      }catch(err){\n        return resolve('FAILED code from from_http, trying to run route');\n      }\n      \n      // console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n      return resolve(appResult);\n        \n    }catch(err){\n      console.error('Error:', SELF.name, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-27T08:23:11.666Z",
  "updatedAt": "2019-04-06T03:55:23.225Z",
  "nodes": []
}