{
  "name": "base.second.cloud.services.second.default.bin.clear",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--Service --', SELF.name, '--');\n      \n      const util = universe.require('util');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n        \n      // INPUT\n      // type: types.second.default.bin.clear.input \n      // data: {\n      //   nodePath,\n      //   target, // default: \"ALL\" \n      //   opts\n      // }\n      \n      // \"data.target\" \n      \n      // TODO: for errors, universe.isError() quick-checker against registered error types \n      \n        \n      let allowedBuildTypes = [\n        'types.second.default.app',\n        'types.second.default.code.js',\n        'types.second.default.service.js',\n        'types.second.default.permissions'\n      ];\n      \n      let {\n        nodePath,\n        target,\n        opts\n      } = INPUT.data;\n        \n      target = target || 'ALL'; \n      opts = universe.lodash.defaults({},opts,{\n        dryRun: false,\n        force: true\n      });\n        \n      // Clear directory \n      // - for selfOrOther (target) or whole directory \n      \n      // Find appNode \n      let node = await universe.getNodeAtPath(nodePath);\n      if(!node){\n        console.error('Missing node for clear');\n        return resolve({\n          error: true,\n          message: 'Missing Node'\n        });\n      }\n      \n      if(allowedBuildTypes.indexOf(node.type) === -1){\n        console.error('Invalid type for clear');\n        return resolve({\n          error: true,\n          message: 'Invalid type of node'\n        });\n      }\n      \n      // Check for \"self\" or other \n      if(target != 'ALL' && !node.data.src[target]){\n        console.error('Missing target for clear');\n        return resolve({\n          error: true,\n          message: 'Missing target'\n        });\n      }\n      \n      \n      var volumePrefix = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath);\n      var targetDir = (target == 'ALL') ? '' : (node.data.src[target].src.targetDir || '');\n      var extractToPath = path.join(volumePrefix, targetDir);\n      \n      console.log('extractToPath:', extractToPath);\n      \n      let toDelete;\n      try {\n        \n        // // fs.emptyDirSync(extractToPath);\n        toDelete = await del([extractToPath + '/**'], {\n          dryRun: opts.dryRun, \n          force: opts.force\n        });\n        console.log('toDelete', extractToPath + '**', toDelete);\n        \n      }catch(err){\n        console.error('Failed deleting:', err);\n        resolve({\n          error: true,\n          message: 'Failed clearing',\n          err,\n          toDelete\n        });\n        \n        return false;\n      }\n      \n      resolve({\n        cleared: true,\n        toDelete\n      });\n      \n      return false;\n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-04-03T21:35:07.813Z",
  "updatedAt": "2019-04-07T06:39:50.275Z",
  "nodes": []
}