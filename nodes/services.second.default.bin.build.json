{
  "name": "base.second.cloud.services.second.default.bin.build",
  "type": "types.second.default.service.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--API binary tool: install --', SELF.name);\n      \n      const util = universe.require('util');\n      const exec = util.promisify(universe.require('child_process').exec);\n      \n      const path = universe.require('path');\n      const mkdirp = universe.require('mkdirp');\n      \n      let fs = universe.require('fs-extra');\n      let request = universe.require('request');\n      let unzipper = universe.require('unzipper');\n      \n      let del = universe.require('del');\n      \n        \n      // INPUT\n      // type: types.second.default.bin.install.build \n      // data: {\n      //   nodePath,\n      //   target, // default: self\n      //   opts\n      // }\n      \n      // TODO: for errors, universe.isError() quick-checker against registered error types \n      \n        \n      let allowedBuildTypes = [\n        'types.second.default.app',\n        'types.second.default.code.js',\n        'types.second.default.service.js',\n        'types.second.default.permissions',\n        'types.second.default.route'\n      ];\n      \n      let {\n        nodePath,\n        target, // \"all\", \"onInstall\" (buildOnInstall:true), self, other\n        opts\n      } = INPUT.data;\n      \n      target = target || 'self'; \n      opts = opts || {};\n      opts = universe.lodash.defaults({},opts,{\n        containerOrCode: 'all'\n      });\n      \n      console.log('Build Opts.containerOrCode:', opts.containerOrCode);\n      \n      // Find appNode \n      node = await universe.getNodeAtPath(nodePath);\n      if(!node){\n        console.error('Missing node for build');\n        return resolve({\n          error: true,\n          message: 'Missing Node'\n        });\n      }\n      \n      if(allowedBuildTypes.indexOf(node.type) === -1){\n        console.error('Invalid type for build');\n        return resolve({\n          error: true,\n          message: 'Invalid type of node'\n        });\n      }\n      \n      let targets = [];\n      switch(target){\n        case 'all':\n          targets = Object.keys(node.data.src).filter(k=>{\n            return node.data.src.hasOwnProperty(k);\n          });\n          break;\n          \n        case 'onInstall':\n          targets = Object.keys(node.data.src).filter(k=>{\n            if(!node.data.src.hasOwnProperty(k)){\n              return false;\n            }\n            let t = node.data.src[k];\n            if(t && t.build && t.build.buildOnInstall){\n              return true;\n            }\n            return false;\n          });\n          break;\n          \n        default:\n          targets = universe.lodash.isArray(target) ? target:[target];\n      }\n      \n      console.log('Targets:', target, targets.length, targets);\n      \n      let buildResults = [];\n      \n      for(let target of targets){\n        \n        console.log('TARGET:',target);\n        \n        let buildResult = {};\n        \n        // Check for \"self\" or other \n        if(!node.data.src[target]){\n          console.error('Missing target for build');\n          buildResult = {\n            target,\n            error: true,\n            message: 'Missing target'\n          };\n          buildResults.push(buildResult);\n          continue;\n        }\n        \n        // Check for valid build parameters \n        if(!node.data.src[target].build){\n          console.error('Missing target.build for build');\n          buildResult = {\n            target,\n            error: true,\n            message: 'Missing target.build'\n          };\n          buildResults.push(buildResult);\n          continue;\n        }\n        \n        var subDirectory = node.data.src[target].src.targetDir || '/';\n        \n        // Using for container/code building \n        var DBUILDER_IMAGE = node.data.src[target].build.image;\n        var DBUILDER_CONTAINER = node.data.src[target].build.container || 'second-container-code-' + node.name + '-' + Date.now();\n        \n        // using for Image building \n        var DBUILDER_CONTEXT = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory); // path for dockerfile? \n        var DBUILDER_DOCKERFILE = node.data.src[target].build.dockerfile || ''; //'dockerfile.second'; \n        var DBUILDER_WORKDIR = DBUILDER_CONTEXT; \n        \n        var DBUILDER_DOCKERFILE_PATH = path.join(universe.env.ATTACHED_VOLUME_ROOT, nodePath, subDirectory, DBUILDER_DOCKERFILE);\n        \n        // Run commands \n        // - Build image using dockerfile (and tag for use in a moment) \n        // - Build app by running special command: \"npm run second:build:self\" \n        // - retain image, or delete it? \n        //   - if dockerfile changes, then change, or provide additional options/apis? \n        \n        // docker run --volumes-from nodejs app_dbuilder:latest /bin/bash -c \\\"cd /usr/src/attached-volume/app.second.sample_pwa && yarn && npm run second:build:${target}\\\"\n        \n        let optsAllowContainer, optsAllowCode, optsAllowDependencies;\n        switch(opts.containerOrCode){\n          // case 'container-only':\n          //   optsAllowContainer = true;\n          //   break;\n          case 'code-only':\n            optsAllowCode = true;\n            break;\n          case 'dependencies-only':\n            optsAllowDependencies = true;\n            break;\n          case 'all':\n            optsAllowContainer = true;\n            optsAllowCode = true;\n            optsAllowDependencies = true;\n            break;\n          default:\n            console.error('Missing containerOrCode:', opts.containerOrCode);\n            buildResult = {\n              target,\n              error: true,\n              message: 'Missing containerOrCode'\n            };\n            buildResults.push(buildResult);\n            continue;\n            break;\n        }\n        \n        let consoleOutput = [];\n        try {\n          \n          var command;\n          \n          // TODO: \n          // - image builder (and push to docker hub, or just use locally) \n          // - for now, just using docker hub images (for simplicity) \n          \n          \n          // // image already created? \n          // if(optsAllowContainer){\n          //   if(!node.data.src[target].build.container){\n          //     console.log('Building container:', DBUILDER_IMAGE);\n          //     if(!DBUILDER_IMAGE || !DBUILDER_IMAGE.length){\n          //       console.error('NO IMAGE TO BUILD CONTAINER WITH!');\n          //     } else {\n          //       command = `DBUILDER_IMAGE=${DBUILDER_IMAGE} DBUILDER_CONTAINER=${DBUILDER_CONTAINER} docker-compose -f docker-compose-builder-container.yml build dbuilder`;\n                \n          //       console.log('Running command:', command);\n                \n          //       var { stdout, stderr } = await exec(command);\n              \n          //       console.error('------------------------------');\n          //       console.error(`---exec error`, stderr);\n          //       console.error('------------------------------');\n                \n          //       console.log('------------------------------');\n          //       console.log(`---exec Run Output`, stdout);\n          //       console.log('------------------------------');\n                \n          //       consoleOutput.push({stderr});\n          //       consoleOutput.push({stdout});\n          //       // Update the node with the new Container name \n          //       // TODO\n          //       node.data.src[target].build.container = DBUILDER_CONTAINER; // \"DBUILDER_NAME:latest\"\n          //       node.data.src[target].build.lastBuiltContainer = new Date();\n          //       await universe.putNodeAtPath(nodePath, node);\n          //     }\n          //   } else {\n          //     console.error('Image already built');\n          //   }\n          // }\n          \n          // Look for \"Successfully built\" in stdout\n          \n          // Install dependencies \n          // - this could be part of a different step? \n          // - Run node command to install packages (yarn) and build \n           if(optsAllowDependencies){\n            var DEPENDENCIES_COMMAND = node.data.src[target].build.dependenciesCommand || 'npm run second:dependencies:self';\n            \n            command = `docker run --volumes-from nodejs ${DBUILDER_IMAGE} /bin/bash -c \"cd ${DBUILDER_CONTEXT} && ${DEPENDENCIES_COMMAND}\"`;\n            \n            console.log('Running command:', command);\n            \n            var { stdout, stderr } = await exec(command);\n          \n            console.error('------------------------------');\n            console.error(`---exec error:`, stderr);\n            console.error('------------------------------');\n            \n            console.log('------------------------------');\n            console.log(`---exec Run Output:`, stdout);\n            console.log('------------------------------');\n            \n            consoleOutput.push({stderr});\n            consoleOutput.push({stdout});\n            \n           }\n           \n           \n           // Run webpack/etc \n           if(optsAllowCode){\n            var BUILD_CODE_COMMAND = node.data.src[target].build.command || 'npm run second:build:self';\n            console.log('Running npm command:', BUILD_CODE_COMMAND);\n            command = `docker run --volumes-from nodejs ${DBUILDER_IMAGE} /bin/bash -c \"cd ${DBUILDER_CONTEXT} && ${BUILD_CODE_COMMAND}\"`;\n            \n            console.log('Running command:', command);\n            \n            var { stdout, stderr } = await exec(command);\n          \n            console.error('------------------------------');\n            console.error(`---exec error:`, stderr);\n            console.error('------------------------------');\n            \n            console.log('------------------------------');\n            console.log(`---exec Run Output:`, stdout);\n            console.log('------------------------------');\n            \n            consoleOutput.push({stderr});\n            consoleOutput.push({stdout});\n              \n            buildResult = {\n              target,\n              built: true,\n              message: 'Success Building',\n              consoleOutput\n            };\n            buildResults.push(buildResult);\n            \n            // Update with when it was last built \n            node.data.src[target].build.lastBuiltCode = new Date();\n            await universe.putNodeAtPath(nodePath, node);\n           }\n          \n        }catch(err){\n          console.error('Failed Command',err);\n          // resolve({\n          //   error: true,\n          //   message: 'Failed',\n          //   err\n          // });\n          // return false;\n          \n          buildResult = {\n            target,\n            error: true,\n            message: 'Failed command',\n            consoleOutput\n          };\n          buildResults.push(buildResult);\n          continue;\n        }\n      }\n      \n      console.log('Done Building');\n      resolve({\n        type: 'types.second.default.bin.build.output',\n        data: {\n          buildResults\n        }\n      })\n      return false;\n    \n        \n        \n    }catch(err){\n      universe.scriptError(err, SELF);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "blobdata": null,
  "createdAt": "2019-03-16T02:18:31.746Z",
  "updatedAt": "2019-03-19T18:42:45.303Z",
  "nodes": []
}